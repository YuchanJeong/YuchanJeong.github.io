[{"content":"제 3장. 노드 기능 알아보기 # 1) 모듈 # CommonJS 모듈\n// 파일 하나당 하나만 가능 module.exports = 데이터; // 파일 하나당 여러개 가능 exports.변수 = 데이터; const 데이터 = require(\u0026#34;경로\u0026#34;); // require.main은 실행한 파일 // require.cache는 캐시된 모듈(한 번 이상 실행된 경우) // 순환 참조 시 자동으로 빈 객체가 됨 ECMAScript 모듈\n// 이름 필수 X, 파일 하나당 하나만 가능 export default 데이터 // 이름 필수 O, 파일 하나당 여러개 가능 export 데이터 // export default import 임의_데이터명 from \u0026#34;경로\u0026#34;; // export import { 데이터명 } from \u0026#34;경로\u0026#34;; import { 데이터명 as 임의_데이터명 } from \u0026#34;경로\u0026#34;; import * as 임의_객체명 from \u0026#34;경로\u0026#34;; CommonJS 모듈과 ES 모듈의 차이점\n차이점 CommonJS 모듈 ES 모듈 최상단 외 사용 가능 불가능 확장자 js, cjs js(package.json에 \u0026ldquo;type\u0026rdquo;: \u0026ldquo;module\u0026rdquo; 필요), mjs 확장자 생략 가능 불가능 인덱스 생략 가능 불가능 top level await[1] 불가능 가능 dynamic import[2] 가능 불가능 __filename,__dirname 사용 가능 사용 불가능(__filename 대신 import.meta.url 사용) [1] top level await: 최상위 스코프에서 await 바로 사용 가능\n[2] dynamic import\nconst a = true; if (a) require(\u0026#34;...\u0026#34;); const a = true if (a) const b = await import(\u0026#34;...\u0026#34;) *CommonJS 모듈과 ES 모듈 간의 호출은 대부분 가능\n*최상위 스코프의 this는 module.exports\nconsole.log(this); // -\u0026gt; {} 2) 노드 내장 객체 # global\n노드의 전역 객체 브라우저의 window(globalThis)와 같은 역할 global에 값을 넣을 경우 다른 파일에서도 사용 가능하지만 지양해야함 console\nMethods Details console.time(로그),console.timeEnd(로그) 시간 로깅 console.log(로그) 시간 로깅 console.table(로그) 테이블로 표시되는 로깅 console.error(로그) 에러 로깅 console.dir(로그) 객체 로깅 console.trace(로그) 호출스택 로깅*함수 내부에서 사용 example\rconst string = \u0026#34;abc\u0026#34;; const number = 1; const boolean = true; const obj = { outside: { inside: { key: \u0026#34;value\u0026#34;, }, }, }; console.time(\u0026#34;전체시간\u0026#34;); console.log(\u0026#34;평범한 로그입니다 쉼표로 구분해 여러 값을 찍을 수 있습니다\u0026#34;); console.log(string, number, boolean); console.error(\u0026#34;에러 메시지는 console.error에 담아주세요\u0026#34;); console.table([ { name: \u0026#34;제로\u0026#34;, birth: 1994 }, { name: \u0026#34;hero\u0026#34;, birth: 1988 }, ]); console.dir(obj, { colors: true, depth: 2 }); console.dir(obj, { colors: false, depth: 1 }); console.time(\u0026#34;시간측정\u0026#34;); for (let i = 0; i \u0026lt; 100000; i++) {} console.timeEnd(\u0026#34;시간측정\u0026#34;); function b() { console.trace(\u0026#34;에러 위치 추적\u0026#34;); } function a() { b(); } a(); console.timeEnd(\u0026#34;전체시간\u0026#34;); 평범한 로그입니다 쉼표로 구분해 여러 값을 찍을 수 있습니다 abc 1 true 에러 메시지는 console.error에 담아주세요 ┌─────────┬────────┬───────┐ │ (index) │ name │ birth │ ├─────────┼────────┼───────┤ │ 0 │ \u0026#39;제로\u0026#39; │ 1994 │ │ 1 │ \u0026#39;hero\u0026#39; │ 1988 │ └─────────┴────────┴───────┘ { outside: { inside: { key: \u0026#39;value\u0026#39; } } } { outside: { inside: [Object] } } 시간측정: 21.228ms Trace: 에러 위치 추적 at b (/Users/yuchanjeong/Desktop/nodejs-book-master/ch3/3.4/console.js:29:11) at Object.\u0026lt;anonymous\u0026gt; (/Users/yuchanjeong/Desktop/nodejs-book-master/ch3/3.4/console.js:32:1) at Module._compile (node:internal/modules/cjs/loader:1155:14) at Object.Module._extensions..js (node:internal/modules/cjs/loader:1209:10) at Module.load (node:internal/modules/cjs/loader:1033:32) at Function.Module._load (node:internal/modules/cjs/loader:868:12) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12) at node:internal/main/run_main_module:22:47 전체시간: 34.557ms process\n현재 실행중인 노드 프로세스에 대한 정보를 담고있음 Properties \u0026amp; Methods Details process.cwd() 실행중인 노드 프로세스 경로 process.env 시스템 환경 변수*노드에 직접 영향을 미치는 변수도 있음ㅤNODE_OPTIONS=\u0026ndash;max-old-space-size=8192 (노드 옵션: 메모리 사이즈)ㅤUV_THREADPOOL_SIZE=8 (스레드 갯수) process.nextTick(콜백) 이벤트 루프가 다른 콜백함수 보다 우선적으로 처리 process.exit(코드) 코드가 없거나 0이면 정상 종료\n*그 외는 비정상 종료 example\r$ node \u0026gt; process.version v18.7.0 // 설치된 노드의 버전입니다 \u0026gt; process.arch x64 // 프로세서 아키텍처 정보입니다. arm, ia32 등의 값일 수도 있습니다 \u0026gt; process.platform win32 // 운영체제 플랫폼 정보입니다. linux나 darwin, freebsd 등의 값일 수도 있습니다 \u0026gt; process.pid 14736 // 현재 프로세스의 아이디입니다. 프로세스를 여러 개 가질 때 구분할 수 있습니다 \u0026gt; process.uptime() 199.36 // 프로세스가 시작된 후 흐른 시간입니다. 단위는 초입니다 \u0026gt; process.execPath C:\\Program Files\\nodejs\\node.exe // 노드의 경로입니다 \u0026gt; process.cwd() C:\\Users\\zerocho // 현재 프로세스가 실행되는 위치입니다 \u0026gt; process.cpuUsage() { user: 390000, system: 203000 } // 현재 cpu 사용량입니다 기타 내장 객체\nURL, URLSearchParams TextDecoder: Buffer를 문자열로 바꿈 TextEncoder: 문자열을 Buffer로 바꿈 WebAssembly: 웹어셈블리 처리 담당 AbortController, FormData, fetch, Headers, Request, Response, Event, EventTarget: 브라우저에서 사용하던 API들 3) 노드 내장 모듈 # 1. os (●○○) # 운영체제의 정보를 담고있는 모듈\nlist\ros.arch(): process.arch와 동일합니다.\nos.platform(): process.platform과 동일합니다.\nos.type(): 운영체제의 종류를 보여줍니다.\nos.uptime(): 운영체제 부팅 이후 흐른 시간(초)을 보여줍니다.\nos.hostname(): 컴퓨터의 이름을 보여줍니다.\nos.release(): 운영체제의 버전을 보여줍니다.\nos.homedir(): 홈 디렉터리 경로를 보여줍니다.\nos.tmpdir(): 임시 파일 저장 경로를 보여줍니다.\nos.cpus(): 컴퓨터의 코어 정보를 보여줍니다.\nos.freemem(): 사용 가능한 메모리(RAM)를 보여줍니다.\nos.totalmem(): 전체 메모리 용량을 보여줍니다.\n2. path (●●○) # 폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈\npath.join(경로, …) vs path.resolve(경로, …)\npath.join(\u0026#34;/a\u0026#34;, \u0026#34;/b\u0026#34;, \u0026#34;c\u0026#34;); /* 결과: /a/b/c/ */ path.resolve(\u0026#34;/a\u0026#34;, \u0026#34;/b\u0026#34;, \u0026#34;c\u0026#34;); /* 결과: /b/c */ Properties \u0026amp; Methods Return path.sep 경로의 구분자*WINDOW는 \u0026ldquo;\\\u0026rdquo;, POSIX(LINUX \u0026amp; MAC)는 \u0026ldquo;/\u0026rdquo; path.delimiter 환경 변수의 구분자 (process.env.PATH를 입력하면 여러 개의 경로가 이 구분자로 구분되어 있음)*WINDOW는 \u0026ldquo;;\u0026rdquo;, POSIX는 \u0026ldquo;:\u0026rdquo; path.dirname(경로) 파일이 위치한 폴더 경로 path.extname(경로) 파일의 확장자 path.basename(경로, [확장자]) 파일의 이름*두 번째 인수를 넣을 경우 파일의 이름만 표시 path.parse(경로) 파일 경로를 root, dir, base, ext, name으로 구분한 객체 path.format(객체) path.parse()의 반환값을 합친 경로 path.normalize(경로) \u0026ldquo;/\u0026ldquo;나 \u0026ldquo;\\\u0026ldquo;를 잘못 사용했을 때 올바르게 변환한 경로 path.isAbsolute(경로) 절대경로인지 여부 path.relative(기준경로, 목표경로) 기준경로에서 목표경로로 가는 경로 example\rconst path = require(\u0026#39;path\u0026#39;); const string = __filename; console.log(\u0026#39;path.sep:\u0026#39;, path.sep); console.log(\u0026#39;path.delimiter:\u0026#39;, path.delimiter); console.log(\u0026#39;------------------------------\u0026#39;); console.log(\u0026#39;path.dirname():\u0026#39;, path.dirname(string)); console.log(\u0026#39;path.extname():\u0026#39;, path.extname(string)); console.log(\u0026#39;path.basename():\u0026#39;, path.basename(string)); console.log(\u0026#39;path.basename - extname:\u0026#39;, path.basename(string, path.extname(string))); console.log(\u0026#39;------------------------------\u0026#39;); console.log(\u0026#39;path.parse()\u0026#39;, path.parse(string)); console.log(\u0026#39;path.format():\u0026#39;, path.format({ dir: \u0026#39;C:\\users\\zerocho\u0026#39;, name: \u0026#39;path\u0026#39;, ext: \u0026#39;.js\u0026#39;, })); console.log(\u0026#39;path.normalize():\u0026#39;, path.normalize(\u0026#39;C://users\\\\zerocho\\\\path.js\u0026#39;)); console.log(\u0026#39;------------------------------\u0026#39;); console.log(\u0026#39;path.isAbsolute(C:\\):\u0026#39;, path.isAbsolute(\u0026#39;C:\\\u0026#39;)); console.log(\u0026#39;path.isAbsolute(./home):\u0026#39;, path.isAbsolute(\u0026#39;./home\u0026#39;)); console.log(\u0026#39;------------------------------\u0026#39;); console.log(\u0026#39;path.relative():\u0026#39;, path.relative(\u0026#39;C:\\users\\zerocho\\path.js\u0026#39;, \u0026#39;C:\\\u0026#39;)); console.log(\u0026#39;path.join():\u0026#39;, path.join(__dirname, \u0026#39;..\u0026#39;, \u0026#39;..\u0026#39;, \u0026#39;/users\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;/zerocho\u0026#39;)); console.log(\u0026#39;path.resolve():\u0026#39;, path.resolve(__dirname, \u0026#39;..\u0026#39;, \u0026#39;users\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;/zerocho\u0026#39;)); path.sep: \\ path.delimiter: ; ------------------------------ path.dirname(): C:\\Users\\zerocho path.extname(): .js path.basename(): path.js path.basename - extname: path ------------------------------ path.parse() { root: \u0026#39;C:\\\u0026#39;, dir: \u0026#39;C:\\Users\\zerocho\u0026#39;, base: \u0026#39;path.js\u0026#39;, ext: \u0026#39;.js\u0026#39;, name: \u0026#39;path\u0026#39; } path.format(): C:\\users\\zerocho\\path.js path.normalize(): C:\\users\\zerocho\\path.js ------------------------------ path.isAbsolute(C:\\): true path.isAbsolute(./home): false ------------------------------ path.relative(): ..\\..\\.. path.join(): C:\\Users\\zerocho path.resolve(): C:\\zerocho 3. url (●●○) # 인터넷 주소를 쉽게 조작하도록 도와주는 모듈 pathname만 있는 주소는 new URL(pathname, host)로 host를 두 번째 인수로 적어줘야 함 .searchParams로 쿼리 스트링을 다룸 Methods Return or Details .searchParams.getAll(키) 키에 해당하는 모든 값 .searchParams.get(키) 키에 해당하는 첫 번째 값 .searchParams.has(키) 해당 키의 존재 여부 .searchParams.keys() 모든 키를 포함한 iterator(반복자 객체) .searchParams.values() 모든 값를 포함한 iterator(반복자 객체) .searchParams.append(키, 값) 해당 키를 추가, 같은 키의 값이 있다면 유지하면서 하나 더 추가 .searchParams.set(키, 값) 해당 키를 제거 .searchParams.toString() 조작한 searchParams 객체를 다시 문자열로 만듦 example\rconst myURL = new URL( \u0026#34;http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor\u0026#34; ); console.log(\u0026#34;new URL():\u0026#34;, myURL); console.log(\u0026#34;url.format():\u0026#34;, url.format(myURL)); new URL(): URL { href: \u0026#39;http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor\u0026#39;, origin: \u0026#39;http://www.gilbut.co.kr\u0026#39;, protocol: \u0026#39;http:\u0026#39;, username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, host: \u0026#39;www.gilbut.co.kr\u0026#39;, hostname: \u0026#39;www.gilbut.co.kr\u0026#39;, port: \u0026#39;\u0026#39;, pathname: \u0026#39;/book/bookList.aspx\u0026#39;, search: \u0026#39;?sercate1=001001000\u0026#39;, searchParams: URLSearchParams { \u0026#39;sercate1\u0026#39; =\u0026gt; \u0026#39;001001000\u0026#39; }, hash: \u0026#39;#anchor\u0026#39; } url.format(): http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor const myURL = new URL( \u0026#34;http://www.gilbut.co.kr/?page=3\u0026amp;limit=10\u0026amp;category=nodejs\u0026amp;category=javascript\u0026#34; ); console.log(\u0026#34;searchParams:\u0026#34;, myURL.searchParams); console.log(\u0026#34;searchParams.getAll():\u0026#34;, myURL.searchParams.getAll(\u0026#34;category\u0026#34;)); console.log(\u0026#34;searchParams.get():\u0026#34;, myURL.searchParams.get(\u0026#34;limit\u0026#34;)); console.log(\u0026#34;searchParams.has():\u0026#34;, myURL.searchParams.has(\u0026#34;page\u0026#34;)); console.log(\u0026#34;searchParams.keys():\u0026#34;, myURL.searchParams.keys()); console.log(\u0026#34;searchParams.values():\u0026#34;, myURL.searchParams.values()); myURL.searchParams.append(\u0026#34;filter\u0026#34;, \u0026#34;es3\u0026#34;); myURL.searchParams.append(\u0026#34;filter\u0026#34;, \u0026#34;es5\u0026#34;); console.log(myURL.searchParams.getAll(\u0026#34;filter\u0026#34;)); myURL.searchParams.set(\u0026#34;filter\u0026#34;, \u0026#34;es6\u0026#34;); console.log(myURL.searchParams.getAll(\u0026#34;filter\u0026#34;)); myURL.searchParams.delete(\u0026#34;filter\u0026#34;); console.log(myURL.searchParams.getAll(\u0026#34;filter\u0026#34;)); console.log(\u0026#34;searchParams.toString():\u0026#34;, myURL.searchParams.toString()); myURL.search = myURL.searchParams.toString(); searchParams: URLSearchParams { \u0026#39;page\u0026#39; =\u0026gt; \u0026#39; 3 \u0026#39;, \u0026#39;limit\u0026#39; =\u0026gt; \u0026#39; 10 \u0026#39;, \u0026#39;category\u0026#39; =\u0026gt; \u0026#39;nodejs\u0026#39;, \u0026#39;category\u0026#39; =\u0026gt; \u0026#39;javascript\u0026#39; } searchParams.getAll(): [ \u0026#39;nodejs\u0026#39;, \u0026#39;javascript\u0026#39; ] searchParams.get(): 10 searchParams.has(): true searchParams.keys(): URLSearchParams Iterator { \u0026#39;page\u0026#39;, \u0026#39;limit\u0026#39;, \u0026#39;category\u0026#39;, \u0026#39;category\u0026#39; } searchParams.values(): URLSearchParams Iterator { \u0026#39; 3 \u0026#39;, \u0026#39; 10 \u0026#39;, \u0026#39;nodejs\u0026#39;, \u0026#39;javascript\u0026#39; } [ \u0026#39;es 3 \u0026#39;, \u0026#39;es 5 \u0026#39; ] [ \u0026#39;es 6 \u0026#39; ] [] searchParams.toString(): page=3\u0026amp;limit=10\u0026amp;category=nodejs\u0026amp;category=javascript 4. dns (●○○) # DNS를 다룰 때 사용하는 모듈 도메인을 통해 IP나 DNS 레코드를 얻고자 할 때 사용 레코드 A(ipv4 주소), AAAA(ipv6 주소), NS(네임서버), SOA(도메인 정보), CNAME(별칭, 주로 www가 붙은 주소), MX(메일 서버) example\rimport dns from \u0026#34;dns/promises\u0026#34;; const ip = await dns.lookup(\u0026#34;gilbut.co.kr\u0026#34;); console.log(\u0026#34;IP\u0026#34;, ip); const a = await dns.resolve(\u0026#34;gilbut.co.kr\u0026#34;, \u0026#34;A\u0026#34;); console.log(\u0026#34;A\u0026#34;, a); const mx = await dns.resolve(\u0026#34;gilbut.co.kr\u0026#34;, \u0026#34;MX\u0026#34;); console.log(\u0026#34;MX\u0026#34;, mx); const cname = await dns.resolve(\u0026#34;www.gilbut.co.kr\u0026#34;, \u0026#34;CNAME\u0026#34;); console.log(\u0026#34;CNAME\u0026#34;, cname); const any = await dns.resolve(\u0026#34;gilbut.co.kr\u0026#34;, \u0026#34;ANY\u0026#34;); console.log(\u0026#34;ANY\u0026#34;, any); IP { address: \u0026#39; 49 . 236 . 151 . 220 \u0026#39;, family: 4 } A [ \u0026#39; 49 . 236 . 151 . 220 \u0026#39; ] MX [ { exchange: \u0026#39;alt 2 .aspmx.l.google.com\u0026#39;, priority: 5 }, { exchange: \u0026#39;aspmx 3 .googlemail.com\u0026#39;, priority: 10 }, { exchange: \u0026#39;aspmx 2 .googlemail.com\u0026#39;, priority: 10 }, { exchange: \u0026#39;aspmx.l.google.com\u0026#39;, priority: 1 }, { exchange: \u0026#39;alt 1 .aspmx.l.google.com\u0026#39;, priority: 5 } ] CNAME [ \u0026#39;slb- 1088813 .ncloudslb.com\u0026#39; ] ANY [ { address: \u0026#39; 49 . 236 . 151 . 220 \u0026#39;, ttl: 14235, type: \u0026#39;A\u0026#39; }, { value: \u0026#39;ns 1 - 2 .ns-ncloud.com\u0026#39;, type: \u0026#39;NS\u0026#39; }, { value: \u0026#39;ns 1 - 1 .ns-ncloud.com\u0026#39;, type: \u0026#39;NS\u0026#39; }, { nsname: \u0026#39;ns 1 - 1 .ns-ncloud.com\u0026#39;, hostmaster: \u0026#39;ns 1 - 2 .ns-ncloud.com\u0026#39;, serial: 32, refresh: 21600, retry: 1800, expire: 1209600, minttl: 300, type: \u0026#39;SOA\u0026#39; } ] 5. crypto (●○○) # 다양한 방식의 암호화를 도와주는 모듈 단방향 암호 - 암호화는 가능하지만 복호화는 불가능, Hash\n문자열을 고정된 길이의 다른 문자열로 바꾸는 방식\n출력 문자열이 같은 경우 충돌이 발생했다고 함\nMethods Details .createHash(해시 알고리즘) md5, sha1, sha256, sha512등의 사용할 해시 알고리즘을 넣음*보안 취약점이 많이 발견 되면서 현재는 pbkdf2, bcrypt, scrypt등의 방식을 사용*노드는 pbkdf2와 scrypt 지원 -.update(문자열) 변환할 문자열을 넣음 -.digest(인코딩) base64, hex, latin1등의 인코딩할 알고리즘을 넣음 pbkdf2\n기존 문자열에 salt(문자열)를 붙인 후 해시 알고리즘을 반복해서 적용하는 방식 params: 비밀번호, salt, 반복 횟수, 출력 바이트, 해시 알고리즘 example\rconst crypto = require(\u0026#34;crypto\u0026#34;); console.log( \u0026#34;base64:\u0026#34;, crypto.createHash(\u0026#34;sha512\u0026#34;).update(\u0026#34;비밀번호\u0026#34;).digest(\u0026#34;base64\u0026#34;) ); // 가장 짧음 console.log( \u0026#34;hex:\u0026#34;, crypto.createHash(\u0026#34;sha512\u0026#34;).update(\u0026#34;비밀번호\u0026#34;).digest(\u0026#34;hex\u0026#34;) ); console.log( \u0026#34;base64:\u0026#34;, crypto.createHash(\u0026#34;sha512\u0026#34;).update(\u0026#34;다른 비밀번호\u0026#34;).digest(\u0026#34;base64\u0026#34;) ); const crypto = require(\u0026#34;crypto\u0026#34;); // randomBytes이므로 매번 실행할 때마다 결과가 달라져서 salt를 잘 보관하고 있어야 비밀번호도 찾을 수 있음 crypto.randomBytes(64, (err, buf) =\u0026gt; { const salt = buf.toString(\u0026#34;base64\u0026#34;); console.log(\u0026#34;salt:\u0026#34;, salt); crypto.pbkdf2(\u0026#34;비밀번호\u0026#34;, salt, 100000, 64, \u0026#34;sha512\u0026#34;, (err, key) =\u0026gt; { console.log(\u0026#34;password:\u0026#34;, key.toString(\u0026#34;base64\u0026#34;)); }); }); 양방향 암호 - 암호화된 문자열을 키로 복호화할 수 있음\n대칭형 암호 - 같은 키 비대칭 암호 - 다른 키 (e.g. https) example\rconst crypto = require(\u0026#34;crypto\u0026#34;); const algorithm = \u0026#34;aes-256-cbc\u0026#34;; const key = \u0026#34;abcdefghijklmnopqrstuvwxyz123456\u0026#34;; const iv = \u0026#34;1234567890123456\u0026#34;; const cipher = crypto.createCipheriv(algorithm, key, iv); let result = cipher.update(\u0026#34;암호화할 문장\u0026#34;, \u0026#34;utf8\u0026#34;, \u0026#34;base64\u0026#34;); result += cipher.final(\u0026#34;base64\u0026#34;); console.log(\u0026#34;암호화:\u0026#34;, result); const decipher = crypto.createDecipheriv(algorithm, key, iv); let result2 = decipher.update(result, \u0026#34;base64\u0026#34;, \u0026#34;utf8\u0026#34;); result2 += decipher.final(\u0026#34;utf8\u0026#34;); console.log(\u0026#34;복호화:\u0026#34;, result2); *키는 AWS kms등으로 잘 관리해 줘야 함\n6. util (●○○) # 각종 편의 기능을 모아둔 모듈 Methods Details util.deprecate(콜백, 메시지) 함수가 deprecated 처리되었음을 알림 util.promisify(콜백) 콜백 패턴을 프로미스 패턴으로 변경(but 콜백이 \u0026ldquo;(err, data) =\u0026gt; {}\u0026rdquo; 여야 함) example\rconst util = require(\u0026#34;util\u0026#34;); const crypto = require(\u0026#34;crypto\u0026#34;); const dontUseMe = util.deprecate((x, y) =\u0026gt; { console.log(x + y); }, \u0026#34;dontUseMe 함수는 deprecated되었으니 더 이상 사용하지 마세요!\u0026#34;); dontUseMe(1, 2); const randomBytesPromise = util.promisify(crypto.randomBytes); randomBytesPromise(64) .then((buf) =\u0026gt; { console.log(buf.toString(\u0026#34;base64\u0026#34;)); }) .catch((error) =\u0026gt; { console.error(error); }); 3 (node:7264) DeprecationWarning: dontUseMe 함수는 deprecated되었으니 더 이상 사용하지 마세요! (Use `node --trace-deprecation ...` to show where the warning was created) 60b4RQbrx1j130x4r95fpZac9lmcHyitqwAm8gKsHQKF8tcNhvcTfW031XaQqHlRKzaVkcENmIV25fDVs3SB7g== 7. worker_threads (●○○) # 노드에서 멀티 스레드를 다루기 위해 사용하는 모듈 스레드를 생성하고 스레드 사이에서 통신하는 데 상당한 비용이 발생하기 때문에 주의가 필요 example\r동작 예제\nconst { Worker, isMainThread, parentPort, workerData, } = require(\u0026#34;worker_threads\u0026#34;); if (isMainThread) { // 부모일 때 const threads = new Set(); threads.add( new Worker(__filename, { workerData: { start: 1 }, }) ); threads.add( new Worker(__filename, { workerData: { start: 2 }, }) ); for (let worker of threads) { worker.on(\u0026#34;message\u0026#34;, (message) =\u0026gt; console.log(\u0026#34;from worker\u0026#34;, message)); worker.on(\u0026#34;exit\u0026#34;, () =\u0026gt; { threads.delete(worker); if (threads.size === 0) { console.log(\u0026#34;job done\u0026#34;); } }); } } else { // 워커일 때 const data = workerData; parentPort.postMessage(data.start + 100); } from worker 101 from worker 102 job done 소수 찾기 예제\nconst { Worker, isMainThread, parentPort, workerData, } = require(\u0026#34;worker_threads\u0026#34;); const min = 2; let primes = []; function findPrimes(start, range) { let isPrime = true; const end = start + range; for (let i = start; i \u0026lt; end; i++) { for (let j = min; j \u0026lt; Math.sqrt(end); j++) { if (i !== j \u0026amp;\u0026amp; i % j === 0) { isPrime = false; break; } } if (isPrime) { primes.push(i); } isPrime = true; } } if (isMainThread) { const max = 10000000; const threadCount = 8; const threads = new Set(); const range = Math.floor((max - min) / threadCount); let start = min; console.time(\u0026#34;prime\u0026#34;); for (let i = 0; i \u0026lt; threadCount - 1; i++) { const wStart = start; threads.add( new Worker(__filename, { workerData: { start: wStart, range } }) ); start += range; } threads.add( new Worker(__filename, { workerData: { start, range: max - start } }) ); for (let worker of threads) { worker.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { throw err; }); worker.on(\u0026#34;exit\u0026#34;, () =\u0026gt; { threads.delete(worker); if (threads.size === 0) { console.timeEnd(\u0026#34;prime\u0026#34;); console.log(primes.length); } }); worker.on(\u0026#34;message\u0026#34;, (msg) =\u0026gt; { primes = primes.concat(msg); }); } } else { findPrimes(workerData.start, workerData.range); parentPort.postMessage(primes); } 8. child_process (●○○) # 노드에서 다른 프로그램을 실행하고 싶거나 명령어를 수행하고 싶을 때 사용하는 모듈 exec 셸을 실행해서 명령어를 수행 stdout을 버퍼로 리턴(정확히는 콜백을 호출) spawn 새로운 프로세스를 띄우면서 명령어를 실행 stdout을 스트림으로 리턴 중간에 출력에 맞춰서 입력을 바꿔 넣을 수 있음 첫 번째 인수로 명령어, 두 번째 인수로 옵션 배열 세 번째 인수로 { shell: true }를 제공하면 exec처럼 셸을 실행해서 명령어를 수행 example\rexec\nconst exec = require(\u0026#34;child_process\u0026#34;).exec; const process = exec(\u0026#34;ls\u0026#34;); process.stdout.on(\u0026#34;data\u0026#34;, function (data) { console.log(\u0026#34;data:\u0026#34;, data.toString()); }); // 실행 결과 process.stderr.on(\u0026#34;data\u0026#34;, function (data) { console.error(\u0026#34;error: \u0026#34;, data.toString()); }); // 실행 에러 spawn\nconst spawn = require(\u0026#34;child_process\u0026#34;).spawn; const process = spawn(\u0026#34;python\u0026#34;, [\u0026#34;test.py\u0026#34;]); process.stdout.on(\u0026#34;data\u0026#34;, function (data) { console.log(data.toString()); }); // 실행 결과 process.stderr.on(\u0026#34;data\u0026#34;, function (data) { console.error(data.toString()); }); // 실행 에러 9. 기타 모듈 # async_hooks: 비동기 코드의 흐름을 추적할 수 있는 실험적인 모듈입니다. dgram: UDP와 관련된 작업을 할 때 사용합니다. net: HTTP보다 로우 레벨인 TCP나 IPC 통신을 할 때 사용합니다. perf_hooks: 성능 측정을 할 때 console.time보다 더 정교하게 측정합니다. querystring: URLSearchParams가 나오기 이전에 쿼리스트링을 다루기 위해 사용했던 모듈입니다. 요즘은 URLSearchParams를 사용하는 것을 권장합니다. string_decoder: 버퍼 데이터를 문자열로 바꾸는 데 사용합니다. tls: TLS와 SSL에 관련된 작업을 할 때 사용합니다. tty: 터미널과 관련된 작업을 할 때 사용합니다. v8: v8 엔진에 직접 접근할 때 사용합니다. vm: 가상 머신에 직접 접근할 때 사용합니다. wasi: 웹어셈블리를 실행할 때 사용하는 실험적인 모듈입니다. 4) fs (●●●) # 동기는 딱 한번 or 초기화 / 서버 실행 된 이후 쓰면 안됨\n스트리밍 하면 메모리를 아낄 수 있다.\n공문 연결?\nfs.existsSync\nfs.stat\nReference.\nhttps://nodejs.org/en/docs https://thebook.io/080334/0122/ https://nodejs.org/api/crypto.html https://www.npmjs.com/package/crypto-js (SHA512(단반향), AES(대칭), RSA(비대칭) 사용 추천) https://stackoverflow.com/questions/48698234/node-js-spawn-vs-execute ","date":"5 April 2023","permalink":"/posts/lectures/node.js-%EA%B5%90%EA%B3%BC%EC%84%9C/2/","section":"Posts","summary":"제 3장.","title":"[Node.js 교과서] Node.js의 기능"},{"content":"","date":"5 April 2023","permalink":"/categories/%5Clectures/","section":"Categories","summary":"","title":"\\lectures"},{"content":"","date":"5 April 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"5 April 2023","permalink":"/tags/node.js/","section":"Tags","summary":"","title":"node.js"},{"content":"","date":"5 April 2023","permalink":"/tags/node.js-%EA%B5%90%EA%B3%BC%EC%84%9C/","section":"Tags","summary":"","title":"Node.js 교과서"},{"content":"","date":"5 April 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"5 April 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" A blog from a developer who loves \u0026ldquo;Why?\u0026rdquo; :) Previous posts are in this repository. 😊 About me # Name Yuchan Jeong Work WithBecon(FE Developer) Languages Korean(Native), English(Intermediate) 👇 Follow me on # Mobile Number +82 10 8295 2674 E-mail yuchanjeong0923@gmail.com Blog https://yuchanjeong.github.io Github /yuchanjeong ","date":"5 April 2023","permalink":"/","section":"Yuchan's hello world!","summary":"A blog from a developer who loves \u0026ldquo;Why?","title":"Yuchan's hello world!"},{"content":"","date":"5 April 2023","permalink":"/tags/%EC%A1%B0%ED%98%84%EC%98%81zerocho/","section":"Tags","summary":"","title":"조현영(zerocho)"},{"content":"제 1장. Node.js란 # 1) 노드의 정의 # Chrome V8 엔진[1]으로 빌드된 자바스크립트 런타임 환경[2] libuv[3]를 내장 [1] Chrome V8 엔진: C++로 작성된 오픈소스 자바스크립트 엔진, 자바스크립트 코드를 기계어로 변환하여 실행시키는 JIT 컴파일러를 내장, 가비지 컬렉터를 내장하고 있어 메모리 관리에 대한 개발자의 부담을 덜어줌\n[2] 런타임 환경: 응용 프로그램이 운영체제(OS)의 시스템 리소스(e.g. RAM, 시스템 변수, 환경 변수)에 엑세스 할 수 있도록 해주는 실행 환경\n[3] libuv: 이벤트 기반의 비동기 I/O 라이브러리, 이벤트 루프 제공\n2) 노드의 특성 # 이벤트 기반 이벤트 리스너에 콜백 함수를 등록해서 이벤트(e.g. 클릭, 네트워크 요청, 타이머) 발생 시 미리 지정해둔 작업 수행 None-Blocking I/O 일부 코드(e.g. I/O 작업(파일 시스템 접근, 네트워크 요청), 압축, 암호화)는 백그라운드(다른 프로세스)에서 논-블로킹으로 실행 나머지 코드는 블로킹으로 실행 즉, I/O 작업이 많을 때 노드 활용성이 극대화 Single Tread 노드 프로세스는 멀티 스레드지만 직접 다룰 수 있는 스레드는 하나라서 싱글 스레드라고 표현 노드 14 버전부터 worker threads 모듈로 멀티 스레드 사용 가능 *프로세스 vs 스레드\n프로세스: 운영체제에서 할당하는 작업의 단위, 프로세스 간 리소스 공유 X 스레드: 프로세스 내에서 실행되는 작업의 단위, 부모 프로세스의 리소스 공유 O *멀티 프로세싱 vs 멀티 스레딩\n멀티 프로세싱: 여러 개의 프로세스 사용, I/O 요청이 많을 때 사용, 프로그래밍이 쉬움, 리소스를 적게 사용 멀티 스레딩: 하나의 프로세스 안에서 여러개의 스레드 사용, CPU 작업이 많을 때 사용, 프로그래밍이 어려움, 리소스를 많이 사용 3) 노드로 만든 서버 # 장점 단점 I/O 작업이 많은 서버에 적합 CPU 작업이 많은 서버에 부적합 리소스를 적게 사용 하나뿐인 스레드가 멈추지 않도록 관리 필요 프로그래밍이 쉬움 어중간한 성능 웹 서버 내장 JSON 형식과 호환이 쉬움 *CPU 작업을 위해 AWS Lamda, Google Cloud Functions 같은 별도 서비스 사용 권장\n4) 콜 스택과 이벤트 루프 # 콜 스택\n가장 먼저 anonymous[1]가 쌓임 호출 순서대로 쌓이고, 역순으로 실행 이벤트 루프\n콜 스택에 쌓인 함수 중 논-블로킹으로 실행되는 함수들[2]을 백그라운드로 보냄 백그라운드에서 해당 함수가 완료되면 태스크 큐로 이동해서 대기 콜 스택이 비는 순간 이벤트 루프가 콜 스택으로 태스크를 이동 시켜서 실행 매크로 태스크[3] 큐(이벤트 큐, 콜백 큐)에서 가장 오래된 태스크를 실행 마이크로 태스크[4] 큐(잡 큐)의 모든 태스크를 오래된 순으로 실행 랜더링 매크로 태스크 큐 확인 및 대기 console.log(\u0026#34;script start\u0026#34;); setTimeout(function () { console.log(\u0026#34;setTimeout\u0026#34;); }, 0); Promise.resolve() .then(function () { console.log(\u0026#34;promise1\u0026#34;); }) .then(function () { console.log(\u0026#34;promise2\u0026#34;); }); console.log(\u0026#34;script end\u0026#34;); # console.log script start script end promise1 promise2 setTimeout *여기서 setTimeout이 첫 번째 매크로 태스크가 아니라 실행중인 스크립트(이벤트)가 첫 번째 매크로 태스크 (JS에서는 이벤트가 발생하지 않으면 코드가 실행되지 않기 때문)\n[1] anonymous: 모듈 스코프 외부에서 선언된 변수, 전역 변수로 취급\n[2] 논-블로킹으로 실행되는 함수들: 타이머 함수, 파일 시스템 접근(fs), 네트워크 요청, 압축(zlib), 암호화(crypto)\n[3] 매크로 태스크: requestAnimationFrame, I/O, UI rendering, setTimeout, setInterval, setImmediate\n[4] 마이크로 태스크: process.nextTick, Promises, queueMicrotask(f), MutationObserver\n*백그라운드와 태스크 큐는 자바스크립트가 아님\n*프로미스 내부는 동기, then/catch/finally는 비동기\n제 2장. Javascript 기초 # JS 기본 문법은 다음 포스팅에 정리. \u0026ldquo;Javascript\u0026rdquo; 부록 # CLI # Command Details node -v node 버전 nvm -v nvm 버전 nvm install [version] 특정 버전 node 설치 nvm uninstall [version] 특정 버전 node 삭제 nvm ls node 목록 nvm use [version] 특정 버전 node 사용 sudo npm i -g npm npm 업데이트 강사 어록 # 생각의 비중이 높아야 한다. 그렇지 않다면 가치가 크지 않은 일을 하고 있을 가능성이 크다.\nReference.\nhttps://blog.bitsrc.io/microtask-and-macrotask-a-hands-on-approach-5d77050e2168 https://ko.javascript.info/ ","date":"2 April 2023","permalink":"/posts/lectures/node.js-%EA%B5%90%EA%B3%BC%EC%84%9C/1/","section":"Posts","summary":"제 1장.","title":"[Node.js 교과서] Node.js란"},{"content":"","date":"14 November 2022","permalink":"/categories/%5Cwork/","section":"Categories","summary":"","title":"\\work"},{"content":"","date":"14 November 2022","permalink":"/tags/i18n/","section":"Tags","summary":"","title":"i18n"},{"content":"","date":"14 November 2022","permalink":"/tags/react/","section":"Tags","summary":"","title":"react"},{"content":"배경 # 새로 진행하고 있는 B2B 프로젝트에 글로벌 진출 기회가 생겨서 다국어 처리를 할 필요가 생겼다.\n검색 결과 리액트에서 다국어 처리를 할 때는 보통 react-i18next나 react-intl을 사용하고 있었다. react-i18next는 번역에만 충실하나 후에 SSR이 필요할 때 next-i18next로 쉽게 전환할 수 있는 장점이 있었고, react-intl은 날짜, 시간, 숫자 등의 포멧팅을 지원하는 장점이 있었다.\n둘 다 이미 많은 사용자를 지니고 있어서 안정성은 확보되었다고 판단했고, 특별한 차이점도 없었기 때문에 npm trends와 npm compare에서 최근 결과가 더 좋은 react-i18next를 도입하기로 결정했다.\n도입 # 구글 스프레드 시트 연동\nhttps://console.cloud.google.com/apis/dashboard 사용자 인증 정보(Credentials) -\u0026gt; 사용자 인증 정보 만들기(CREATE CREDENTIALS) -\u0026gt; 서비스 계정(Service account) 서비스 계정(Service Accounts)에서 방금 생성한 계정 클릭 키(KEYS) 탭에서 JSON 파일로 새 키 만들기 세부정보(DETAILS) 탭에서 이메일 복사 후 구글 스프레드 시트에서 공유 설정 설치\nyarn add react-i18next i18next @types/react-i18next @types/i18next i18next-scanner google-spreadsheet 설정\nsrc/i18n/index.ts\rimport i18n from \u0026#34;i18next\u0026#34;; import { initReactI18next } from \u0026#34;react-i18next\u0026#34;; import { platform } from \u0026#34;modules/native\u0026#34;; import enUS from \u0026#34;./locales/en-US/translation.json\u0026#34;; import esES from \u0026#34;./locales/es-ES/translation.json\u0026#34;; import jaJP from \u0026#34;./locales/ja-JP/translation.json\u0026#34;; import koKR from \u0026#34;./locales/ko-KR/translation.json\u0026#34;; import viVN from \u0026#34;./locales/vi-VN/translation.json\u0026#34;; //*i18next: 언어 추가 시 작성 필요 const RESOURCES = { ko: { translation: koKR }, en: { translation: enUS }, ja: { translation: jaJP }, vi: { translation: viVN }, es: { translation: esES }, } as const; export type TLanguageCode = keyof typeof RESOURCES; export type TLanguageName = | \u0026#34;한국어\u0026#34; | \u0026#34;English\u0026#34; | \u0026#34;日本語\u0026#34; | \u0026#34;Tiếng Việt\u0026#34; | \u0026#34;español\u0026#34;; export type TLanguage = [TLanguageCode, TLanguageName]; export const LANGUAGES: TLanguage[] = [ [\u0026#34;ko\u0026#34;, \u0026#34;한국어\u0026#34;], [\u0026#34;en\u0026#34;, \u0026#34;English\u0026#34;], [\u0026#34;ja\u0026#34;, \u0026#34;日本語\u0026#34;], [\u0026#34;vi\u0026#34;, \u0026#34;Tiếng Việt\u0026#34;], [\u0026#34;es\u0026#34;, \u0026#34;español\u0026#34;], ]; const browserLang = window.navigator.language.split(\u0026#34;-\u0026#34;)[0]; export const CURRENT_LANGUAGE = \u0026#34;withbecon_language\u0026#34;; const userLanguage = platform !== \u0026#34;web\u0026#34; ? browserLang : localStorage.getItem(CURRENT_LANGUAGE) || browserLang; i18n.use(initReactI18next).init({ resources: RESOURCES, lng: userLanguage, fallbackLng: \u0026#34;en\u0026#34;, debug: false, defaultNS: \u0026#34;translation\u0026#34;, ns: \u0026#34;translation\u0026#34;, keySeparator: false, interpolation: { escapeValue: true, alwaysFormat: true, format(value, format, lng) { if (format === \u0026#34;uppercase\u0026#34;) return value.toUpperCase(); if (typeof value === \u0026#34;number\u0026#34;) return value.toLocaleString(lng); return value; }, }, react: { defaultTransParent: \u0026#34;div\u0026#34;, transEmptyNodeValue: \u0026#34;\u0026#34;, transSupportBasicHtmlNodes: true, transKeepBasicHtmlNodesFor: [ \u0026#34;br\u0026#34;, \u0026#34;strong\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;button\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;span\u0026#34;, \u0026#34;div\u0026#34;, \u0026#34;input\u0026#34;, ], transWrapTextNodes: \u0026#34;\u0026#34;, }, nsSeparator: \u0026#34;=\u0026gt;\u0026#34;, // default: \u0026#34;:\u0026#34; returnNull: false, returnEmptyString: false, }); export default i18n; export interface Ii18Next { // eslint-disable-next-line @typescript-eslint/ban-types t: (str: string, option?: Object) =\u0026gt; string; } export const i18nextScanKey = (key: string): string =\u0026gt; key; i18next-scanner.config.js\r/* eslint-disable import/order */ /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const typescript = require(\u0026#34;typescript\u0026#34;); const COMMON_EXTENSIONS = \u0026#34;/**/*.{js,jsx,ts,tsx,vue,html}\u0026#34;; module.exports = { input: [`./src/${COMMON_EXTENSIONS}`], options: { debug: true, removeUnusedKeys: true, defaultLng: \u0026#34;ko-KR\u0026#34;, //*i18next: 언어 추가 시 작성 필요 lngs: [\u0026#34;ko-KR\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;], func: { list: [\u0026#34;i18next.t\u0026#34;, \u0026#34;i18n.t\u0026#34;, \u0026#34;$i18n.t\u0026#34;, \u0026#34;$i18next.t\u0026#34;, \u0026#34;i18nextScanKey\u0026#34;], extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;], }, trans: { component: \u0026#34;Trans\u0026#34;, i18nKey: \u0026#34;i18nKey\u0026#34;, defaultsKey: \u0026#34;defaults\u0026#34;, extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;], fallbackKey: function (ns, value) { return value; }, acorn: { ecmaVersion: 10, sourceType: \u0026#34;module\u0026#34;, }, }, resource: { loadPath: path.join(__dirname, \u0026#34;/src/i18n/locales/{{lng}}/{{ns}}.json\u0026#34;), savePath: path.join(__dirname, \u0026#34;/src/i18n/locales/{{lng}}/{{ns}}.json\u0026#34;), }, defaultValue(lng, ns, key) { const keyAsDefaultValue = [\u0026#34;ko-KR\u0026#34;]; if (keyAsDefaultValue.includes(lng)) { const separator = \u0026#34;html\u0026#34;; const value = key.includes(separator) ? \u0026#34;\u0026#34; : key; return value; } return \u0026#34;\u0026#34;; }, keySeparator: false, nsSeparator: false, prefix: \u0026#34;{{\u0026#34;, suffix: \u0026#34;}}\u0026#34;, }, transform: (function typescriptTransform( options = { tsOptions: { target: \u0026#34;es2018\u0026#34;, }, extensions: [\u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;], } ) { return function transform(file, enc, done) { const { base, ext } = path.parse(file.path); if ( options.extensions.includes(ext) \u0026amp;\u0026amp; !base.endsWith(\u0026#34;.d.ts\u0026#34;) \u0026amp;\u0026amp; base.indexOf(\u0026#34;reportWebVitals.ts\u0026#34;) === -1 ) { const content = fs.readFileSync(file.path, enc); const { outputText } = typescript.transpileModule(content, { compilerOptions: options.tsOptions, fileName: path.basename(file.path), }); this.parser.parseTransFromString(outputText); this.parser.parseFuncFromString(outputText); } done(); }; })({ extensions: [\u0026#34;.tsx\u0026#34;, \u0026#34;.ts\u0026#34;], tsOptions: { target: \u0026#34;es5\u0026#34;, module: \u0026#34;esnext\u0026#34;, }, }), }; translate/.credentials/...\r.gitignore에 translate/.credentials 추가 서비스 계정에서 받은 JSON 키 파일을 translate/.credentials에 저장 translate/.credentials/index.js module.exports = { CREDS: \u0026#34;서비스 계정에서 받은 JSON 키 파일 이름\u0026#34;, // 구글 스프레드 시트 주소에 나와 있음 SHEET_DOC_ID: \u0026#34;...\u0026#34;, SHEET_ID: \u0026#34;...\u0026#34;, }; translate/index.js\r/* eslint-disable import/order */ /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const { GoogleSpreadsheet } = require(\u0026#34;google-spreadsheet\u0026#34;); const ENV = require(\u0026#34;./.credentials/index.js\u0026#34;); const creds = require(\u0026#34;./.credentials/\u0026#34; + ENV.CREDS); const i18nextConfig = require(\u0026#34;../i18next-scanner.config\u0026#34;); const spreadsheetDocId = ENV.SHEET_DOC_ID; const ns = \u0026#34;translation\u0026#34;; const lngs = i18nextConfig.options.lngs; const loadPath = i18nextConfig.options.resource.loadPath; const localesPath = loadPath.replace(\u0026#34;/{{lng}}/{{ns}}.json\u0026#34;, \u0026#34;\u0026#34;); const rePluralPostfix = new RegExp(/_plural|_[\\d]/g); const sheetId = ENV.SHEET_ID; const NOT_AVAILABLE_CELL = \u0026#34;_N/A\u0026#34;; //*i18next: 언어 추가 시 작성 필요 const columnKeyToHeader = { key: \u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;: \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;: \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;: \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;: \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;: \u0026#34;es-ES\u0026#34;, }; async function loadSpreadsheet() { // eslint-disable-next-line no-console console.info( \u0026#34;\\u001B[32m\u0026#34;, \u0026#34;=====================================================================================================================\\n\u0026#34;, \u0026#34;# i18next auto-sync using Spreadsheet\\n\\n\u0026#34;, \u0026#34; * Download translation resources from Spreadsheet and make /src/i18n/locales/{{lng}}/{{ns}}.json\\n\u0026#34;, \u0026#34; * Upload translation resources to Spreadsheet.\\n\\n\u0026#34;, `The Spreadsheet for translation is here (\\u001B[34mhttps://docs.google.com/spreadsheets/d/${spreadsheetDocId}/#gid=${sheetId}\\u001B[0m)\\n`, \u0026#34;=====================================================================================================================\u0026#34;, \u0026#34;\\u001B[0m\u0026#34; ); const doc = new GoogleSpreadsheet(spreadsheetDocId); await doc.useServiceAccountAuth(creds); await doc.loadInfo(); return doc; } function getPureKey(key = \u0026#34;\u0026#34;) { return key.replace(rePluralPostfix, \u0026#34;\u0026#34;); } module.exports = { localesPath, loadSpreadsheet, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, }; translate/upload.js\r/* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const { loadSpreadsheet, localesPath, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); //TODO-i18next: 언어 추가 시 작성 필요 const headerValues = [\u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;]; async function addNewSheet(doc, title, sheetId) { const sheet = await doc.addSheet({ sheetId, title, headerValues, }); return sheet; } async function updateTranslationsFromKeyMapToSheet(doc, keyMap) { const title = \u0026#34;시트 제목\u0026#34;; let sheet = doc.sheetsById[sheetId]; if (!sheet) { sheet = await addNewSheet(doc, title, sheetId); } const rows = await sheet.getRows(); const exsitKeys = {}; const addedRows = []; rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; if (keyMap[key]) { exsitKeys[key] = true; } }); for (const [key, translations] of Object.entries(keyMap)) { if (!exsitKeys[key]) { const row = { [columnKeyToHeader.key]: key, ...Object.keys(translations).reduce((result, lng) =\u0026gt; { const header = columnKeyToHeader[lng]; result[header] = translations[lng]; return result; }, {}), }; addedRows.push(row); } } await sheet.addRows(addedRows); } function toJson(keyMap) { const json = {}; Object.entries(keyMap).forEach(([, keysByPlural]) =\u0026gt; { for (const [keyWithPostfix, translations] of Object.entries(keysByPlural)) { json[keyWithPostfix] = { ...translations, }; } }); return json; } function gatherKeyMap(keyMap, lng, json) { for (const [keyWithPostfix, translated] of Object.entries(json)) { const key = getPureKey(keyWithPostfix); if (!keyMap[key]) { keyMap[key] = {}; } const keyMapWithLng = keyMap[key]; if (!keyMapWithLng[keyWithPostfix]) { keyMapWithLng[keyWithPostfix] = lngs.reduce((initObj, lng) =\u0026gt; { initObj[lng] = NOT_AVAILABLE_CELL; return initObj; }, {}); } keyMapWithLng[keyWithPostfix][lng] = translated; } } async function updateSheetFromJson() { const doc = await loadSpreadsheet(); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } const keyMap = {}; lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; // eslint-disable-next-line no-sync const json = fs.readFileSync(localeJsonFilePath, \u0026#34;utf8\u0026#34;); gatherKeyMap(keyMap, lng, JSON.parse(json)); }); updateTranslationsFromKeyMapToSheet(doc, toJson(keyMap)); }); } updateSheetFromJson(); /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const { loadSpreadsheet, localesPath, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); //*i18next: 언어 추가 시 작성 필요 const headerValues = [\u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;]; async function addNewSheet(doc, title, sheetId) { const sheet = await doc.addSheet({ sheetId, title, headerValues, }); return sheet; } async function updateTranslationsFromKeyMapToSheet(doc, keyMap) { const title = \u0026#34;B2B\u0026#34;; let sheet = doc.sheetsById[sheetId]; if (!sheet) { sheet = await addNewSheet(doc, title, sheetId); } const rows = await sheet.getRows(); const exsitKeys = {}; const addedRows = []; rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; if (keyMap[key]) { exsitKeys[key] = true; } }); for (const [key, translations] of Object.entries(keyMap)) { if (!exsitKeys[key]) { const row = { [columnKeyToHeader.key]: key, ...Object.keys(translations).reduce((result, lng) =\u0026gt; { const header = columnKeyToHeader[lng]; result[header] = translations[lng]; return result; }, {}), }; addedRows.push(row); } } await sheet.addRows(addedRows); } function toJson(keyMap) { const json = {}; Object.entries(keyMap).forEach(([, keysByPlural]) =\u0026gt; { for (const [keyWithPostfix, translations] of Object.entries(keysByPlural)) { json[keyWithPostfix] = { ...translations, }; } }); return json; } function gatherKeyMap(keyMap, lng, json) { for (const [keyWithPostfix, translated] of Object.entries(json)) { const key = getPureKey(keyWithPostfix); if (!keyMap[key]) { keyMap[key] = {}; } const keyMapWithLng = keyMap[key]; if (!keyMapWithLng[keyWithPostfix]) { keyMapWithLng[keyWithPostfix] = lngs.reduce((initObj, lng) =\u0026gt; { initObj[lng] = NOT_AVAILABLE_CELL; return initObj; }, {}); } keyMapWithLng[keyWithPostfix][lng] = translated; } } async function updateSheetFromJson() { const doc = await loadSpreadsheet(); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } const keyMap = {}; lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; // eslint-disable-next-line no-sync const json = fs.readFileSync(localeJsonFilePath, \u0026#34;utf8\u0026#34;); gatherKeyMap(keyMap, lng, JSON.parse(json)); }); updateTranslationsFromKeyMapToSheet(doc, toJson(keyMap)); }); } updateSheetFromJson(); translate/download.js\r/* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const mkdirp = require(\u0026#34;mkdirp\u0026#34;); const { loadSpreadsheet, localesPath, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); /** * fetch translations from google spread sheet and transform to json * @param {GoogleSpreadsheet} doc GoogleSpreadsheet document * @returns [object] translation map * { * \u0026#34;ko-KR\u0026#34;: { * \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; * }, * \u0026#34;en-US\u0026#34;: { * \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; * }, * } */ async function fetchTranslationsFromSheetToJson(doc) { const sheet = doc.sheetsById[sheetId]; if (!sheet) { return {}; } const lngsMap = {}; const rows = await sheet.getRows(); rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; lngs.forEach((lng) =\u0026gt; { const translation = row[columnKeyToHeader[lng]]; if (translation === NOT_AVAILABLE_CELL) { return; } if (!lngsMap[lng]) { lngsMap[lng] = {}; } lngsMap[lng][key] = translation || \u0026#34;\u0026#34;; }); }); return lngsMap; } function checkAndMakeLocaleDir(dirPath, subDirs) { return new Promise((resolve) =\u0026gt; { subDirs.forEach((subDir, index) =\u0026gt; { mkdirp(`${dirPath}/${subDir}`, (err) =\u0026gt; { if (err) { throw err; } if (index === subDirs.length - 1) { resolve(); } }); }); }); } async function updateJsonFromSheet() { await checkAndMakeLocaleDir(localesPath, lngs); const doc = await loadSpreadsheet(); const lngsMap = await fetchTranslationsFromSheetToJson(doc); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; const jsonString = JSON.stringify(lngsMap[lng], null, 2); fs.writeFile(localeJsonFilePath, jsonString, \u0026#34;utf8\u0026#34;, (err) =\u0026gt; { if (err) { throw err; } }); }); }); } updateJsonFromSheet(); src/index.tsx\rimport \u0026#34;i18n\u0026#34;; ... package.json\r\u0026#34;scripts\u0026#34;: { ..., \u0026#34;scan:i18n\u0026#34;: \u0026#34;i18next-scanner --config i18next-scanner.config.js\u0026#34;, \u0026#34;upload:i18n\u0026#34;: \u0026#34;yarn run scan:i18n \u0026amp;\u0026amp; node translate/upload.js\u0026#34;, \u0026#34;download:i18n\u0026#34;: \u0026#34;node translate/download.js\u0026#34; }, 사용법 # # i18next.t()로 감싸져 있는 키를 스캔 후 업로드 yarn upload:i18n # 구글 스프레드 시트에서 번역을 받아옴 yarn download:i18n import { Trans, useTranslation } from \u0026#34;react-i18next\u0026#34;; import type { Ii18Next } from \u0026#39;i18n\u0026#39;; export default function Example() { const i18next = useTranslation(); // scan을 위한 자체 컨벤션으로 \u0026#34;i18next\u0026#34; 사용 const getTabList = (i18next: Ii18Next) =\u0026gt; [ { id: 1, label: i18next.t(\u0026#34;예시 1\u0026#34;) }, { id: 2, label: i18next.t(\u0026#34;예시 2\u0026#34;) }, { id: 3, label: i18next.t(\u0026#34;예시 3\u0026#34;) }, ]; const tabList = getTabList(i18next); return ( \u0026lt;div\u0026gt; // 1) 일반 사용 {i18next.t(\u0026#34;이메일\u0026#34;)} // 2) 변수 사용 {i18next.t( `이메일은 \u0026#34;{{email}}\u0026#34;이고 , 비밀번호는 \u0026#34;{{password}}\u0026#34;이다.`, { email: \u0026#34;example@gmail.com\u0026#34;, password: \u0026#34;1234\u0026#34; }, )} // 3) 단수・복수 사용; 변수명으로 count를 사용 해야함 {i18next.t(`같은 명의로 만들어진 아이디는 {{count}}개입니다.`, { count: 3 })} // 4) html 태그 사용; i18nKey에 \u0026#34;html\u0026#34;을 포함 해야함 (scan을 위한 자체 컨벤션) \u0026lt;Trans i18nKey=\u0026#34;예시 html\u0026#34;\u0026gt; {{ name: \u0026#34;정유찬\u0026#34; }}님은 i18next를 \u0026lt;br /\u0026gt; 사용할 수 있습니다. \u0026lt;/Trans\u0026gt; // 5) return 외부에서 사용 {tabList.map((tab) =\u0026gt; ( \u0026lt;div\u0026gt; {tab.label} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt;; ) } *조건부 서식을 활용해서 작업이 필요한 부분의 가시성을 높혔다.\nPs. 언어 변경 Select\rimport { useEffect } from \u0026#34;react\u0026#34;; import { useSelect } from \u0026#34;hooks/useSelect\u0026#34;; import i18n, { CURRENT_LANGUAGE, LANGUAGE_LIST } from \u0026#34;i18n\u0026#34;; export default function LanguageSelector() { const languageSelect = useSelect( LANGUAGE_LIST.findIndex((language) =\u0026gt; language[0] === i18n.language) !== -1 ? i18n.language : \u0026#34;ko\u0026#34; ); useEffect(() =\u0026gt; { i18n.changeLanguage(languageSelect.value); localStorage.setItem(CURRENT_LANGUAGE, languageSelect.value); }, [languageSelect.value]); return ( \u0026lt;select {...languageSelect.attribute}\u0026gt; {LANGUAGE_LIST.map((language) =\u0026gt; ( \u0026lt;option key={language[0]} value={language[0]}\u0026gt; {language[1]} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ); } import { useState, ChangeEvent, SelectHTMLAttributes, DetailedHTMLProps, } from \u0026#34;react\u0026#34;; type TUseSelectProps = { initialValue?: string; selectAttributes?: DetailedHTMLProps\u0026lt; SelectHTMLAttributes\u0026lt;HTMLSelectElement\u0026gt;, HTMLSelectElement \u0026gt;; }; export const useSelect = ({ initialValue = \u0026#34;\u0026#34;, selectAttributes = {}, }: TUseSelectProps = {}) =\u0026gt; { const [value, setValue] = useState(initialValue); const onChange = (event: ChangeEvent\u0026lt;HTMLSelectElement\u0026gt;) =\u0026gt; { const newValue = event.target.value; if (newValue !== value) setValue(newValue); }; return { attribute: { value, onChange, ...selectAttributes }, value, setValue, }; }; Reference.\nhttps://npmtrends.com/react-i18next-vs-react-intl https://npmcompare.com/compare/i18n-react,react-i18next,react-intl,react-intl-redux [React] 국제화(internationalization, i18n) 라이브러리 비교 https://www.i18next.com/ 기존 프로젝트에 다국어 처리를 적용해보자(react-i18next) ","date":"14 November 2022","permalink":"/posts/work/5/","section":"Posts","summary":"배경 # 새로 진행하고 있는 B2B 프로젝트에 글로벌 진출 기회가 생겨서 다국어 처리를 할 필요가 생겼다.","title":"다국어 처리 (react-i18next)"},{"content":"Axios Instance # base url 설정, 헤더에 액세스 토큰 포함, 액세스 토큰 만료 시 재발급 그리고 리프레시 토큰 만료 시 로그아웃을 axiosInstance를 통해 공통 설정으로 처리했다.\nyarn add axios axiosInstance.ts\rimport axios from \u0026#34;axios\u0026#34;; import { getAccessToken, logout, TOKEN_INFO } from \u0026#34;modules/account/apis\u0026#34;; import type { AxiosRequestConfig, AxiosResponse, AxiosError } from \u0026#34;axios\u0026#34;; // ===== Setting ===== // //# Set URL const config: AxiosRequestConfig = { baseURL: `https://${process.env.REACT_APP_BRANCH}.becon-api.com`, }; export const axiosInstance = axios.create(config); //# Set Authorization export const setAxiosHeader = (accessToken: string) =\u0026gt; { axiosInstance.defaults.headers.common.Authorization = `Bearer ${accessToken}`; }; // ===== Preprocessing ===== // //# Fulfilled Response (200번대 응답) const onFulfilled = (res: AxiosResponse): AxiosResponse =\u0026gt; { return res; }; //# Rejected Response (200번대 외 응답) const onRejected = async (err: AxiosError): Promise\u0026lt;AxiosResponse\u0026gt; =\u0026gt; { const { config, response } = err; if (!config) return Promise.reject(err); // [edge-case] 요청의 설정이 없을 시 //## Access Token 만료 시 if (response?.status === 401) { const tokenInfoStr = localStorage.getItem(TOKEN_INFO); if (!tokenInfoStr) return Promise.reject(err); // [edge-case] Local Storage에 정보가 없을 시 const tokenInfo: { accessToken: string; refreshToken: string; } = JSON.parse(tokenInfoStr); try { // 0. Refresh Token으로 새로운 Access Token 획득 const newAccessToken = await getAccessToken({ refreshToken: tokenInfo.refreshToken, }); // 1. 권한 부여 헤더의 Access Token 교체 setAxiosHeader(newAccessToken); // 2. Local Storage의 Access Token 교체 localStorage.setItem( TOKEN_INFO, JSON.stringify({ ...tokenInfo, accessToken: newAccessToken, }) ); // 3. 현재 요청의 Access Token 교체 if (!config.headers) config.headers = {}; // [edge-case] 요청에 헤더가 없을 시 config.headers.Authorization = `Bearer ${newAccessToken}`; return axiosInstance(config); } catch (err: unknown) { // [edge-case] Refresh Token 만료 시 logout({ isExpired: true }); return Promise.reject(err); } } return Promise.reject(err); }; axiosInstance.interceptors.response.use(onFulfilled, onRejected); account/apis/index.ts\rexport const ID = \u0026#34;withbecon_id\u0026#34;; export const TOKEN_INFO = \u0026#34;withbecon_token_info\u0026#34;; export const EXPIRED = \u0026#34;withbecon_expired\u0026#34;; export const INVALID = \u0026#34;withbecon_invalid\u0026#34;; /** 이메일 로그인 */ export const emailLogin = async ({ email, password, }: { email: string; password: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ result: TLogin }\u0026gt;(\u0026#34;/account/auth\u0026#34;, { email, password, }); const tokenInfo = { accessToken: res.data.result.access_token, refreshToken: res.data.result.refresh_token, }; setAxiosHeader(tokenInfo.accessToken); localStorage.setItem(ID, email); localStorage.setItem(TOKEN_INFO, JSON.stringify(tokenInfo)); return res.data.result; }; /** 휴대폰번호 로그인 */ export const phoneNumberLogin = async ({ phone_number, password, }: { phone_number: string; password: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ result: TLogin }\u0026gt;( \u0026#34;/account/auth/phone\u0026#34;, { phone_number, password, } ); const tokenInfo = { accessToken: res.data.result.access_token, refreshToken: res.data.result.refresh_token, }; setAxiosHeader(tokenInfo.accessToken); localStorage.setItem(ID, phone_number); localStorage.setItem(TOKEN_INFO, JSON.stringify(tokenInfo)); return res.data.result; }; /** 로그아웃 (query X) */ export const logout = ({ isExpired, isInvalid, }: { isExpired?: boolean; isInvalid?: boolean; } = {}) =\u0026gt; { if (isExpired) localStorage.setItem(EXPIRED, EXPIRED); if (isInvalid) localStorage.setItem(INVALID, INVALID); localStorage.removeItem(TOKEN_INFO); window.location.replace(window.location.origin); }; /** 엑세스 토큰 조회 (query X) */ export const getAccessToken = async ({ refreshToken, }: { refreshToken: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ access_token: string }\u0026gt;( \u0026#34;account/auth/refresh\u0026#34;, { refresh_token: refreshToken } ); return res.data.access_token; }; /** 어카운트 정보 조회 */ export const getAccount = async () =\u0026gt; { const res = await axiosInstance.get\u0026lt;{ account: TAccount }\u0026gt;(\u0026#34;my/account\u0026#34;); return res.data.account; }; React Query # yarn add @tanstack/react-query @tanstack/react-query-devtools index.tsx\rconst root = ReactDOM.createRoot( document.getElementById(\u0026#34;root\u0026#34;) as HTMLElement ); root.render( \u0026lt;QueryClientProvider client={queryClient}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;ReactQueryDevtools /\u0026gt; \u0026lt;/QueryClientProvider\u0026gt; ); queryClient.tsx\rconst generateQueryClient = (): QueryClient =\u0026gt; { return new QueryClient({ defaultOptions: { queries: { suspense: true, refetchOnWindowFocus: false, retry: 1, onError: queryErrorHandler, }, mutations: { onError: queryErrorHandler, }, }, }); }; export const queryClient = generateQueryClient(); queryErrorHandler.ts\rconst queryErrorHandler = (err: unknown): void =\u0026gt; { alert(`withbecon server error -\u0026gt; ${err}`); window.location.replace(window.location.origin); }; export default queryErrorHandler; ","date":"13 November 2022","permalink":"/posts/work/4/","section":"Posts","summary":"Axios Instance # base url 설정, 헤더에 액세스 토큰 포함, 액세스 토큰 만료 시 재발급 그리고 리프레시 토큰 만료 시 로그아웃을 axiosInstance를 통해 공통 설정으로 처리했다.","title":"[프로젝트 초기 설정] Axios Instance \u0026 React Query"},{"content":"","date":"13 November 2022","permalink":"/tags/axios/","section":"Tags","summary":"","title":"axios"},{"content":"","date":"13 November 2022","permalink":"/tags/react-query/","section":"Tags","summary":"","title":"react-query"},{"content":"코드 스플리팅 # 리액트에서 활용 가능한 여러 방식의 코드 스플리팅이 있지만 우선 회사의 다른 프로젝트에서 사용하고 있는 loadable component를 활용한 페이지(라우팅) 기반의 코드 스플리팅만 적용 했다.\nyarn add @loadable/component @types/loadable__component App.tsx\nimport loadable from \u0026#34;@loadable/component\u0026#34;; ... const ExamplePage = loadable(() =\u0026gt; import(\u0026#34;pages/ExamplePage\u0026#34;)) ... function App() { return ( \u0026lt;Router\u0026gt; \u0026lt;Routes\u0026gt; \u0026lt;Route path=\u0026#34;/example\u0026#34; element={\u0026lt;ExamplePage /\u0026gt;} /\u0026gt; ... \u0026lt;Route path=\u0026#34;*\u0026#34; element={\u0026lt;NotFound /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/Router\u0026gt; ) } SASS(SCSS) # /* ===== 1) reset ===== */ @import \u0026#34;base/reset\u0026#34;; /* ... */ * { margin: 0; padding: 0; font: inherit; color: inherit; } *, :after, :before { box-sizing: border-box; flex-shrink: 0; } :root { line-height: 1.5; -moz-tab-size: 4; tab-size: 4; cursor: default; // 모바일에서 꾹 클릭 시 색상 변경 방지 -webkit-tap-highlight-color: transparent; // 내용 선택 방지 -webkit-touch-callout: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; // 모바일에서 폰트 크기 조정 방지 -webkit-text-size-adjust: none; -moz-text-size-adjust: none; text-size-adjust: none; // 글이 상자 벗어나는 거 방지 overflow-wrap: break-word; // 폰트 랜더링 부드럽게 만들기 -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; } html, body { height: 100%; // 최상위 부모 요소 기본 크기 설정 font-size: 62.5%; // 1rem === 10px font-weight: 400; font-style: normal; } img { -webkit-user-drag: none; } img, picture, video, canvas, svg { // 위치값을 가지고 상자 벗어나는거 방지 display: block; max-width: 100%; } // Chrome 자동 완성 배경색 지우기 input:-webkit-autofill { box-shadow: 0 0 0 30px transparent inset; } input:-webkit-autofill, input:-webkit-autofill:hover, input:-webkit-autofill:focus, input:-webkit-autofill:active { transition: background-color 5000s ease-in-out 0s; } // 선택 및 입력 스타일 초기화 button, input, select, progress { appearance: none; -webkit-appearance: none; background-color: transparent; border: 0; \u0026amp;:focus, \u0026amp;:active { outline: none; box-shadow: none; } } meter { border: 0; } textarea { \u0026amp;:focus, \u0026amp;:active { box-shadow: none; outline: none; } } // 입력 대상 커서 텍스트로 변경 input, textarea { cursor: text; } // 선택 대상 커서 포인터로 변경 a, button, select, input[type=\u0026#34;checkbox\u0026#34;], input[type=\u0026#34;radio\u0026#34;], input[type=\u0026#34;range\u0026#34;], label { cursor: pointer; } // 링크 스타일 초기화 a { text-decoration: none; } // 표 스타일 초기와 table { border-collapse: collapse; border-spacing: 0; } // 목록 스타일 초기화 ul, ol { padding-left: 0; list-style: none; } *_(underscore)를 scss 파일 이름 앞에 붙일 경우 부분 파일로 취급해서 작업 시점에는 모듈화되어 있지만 실제로 사용되는 시점에는 main.scss 파일 하나에 작성된다.\nReference.\n코드 스플리팅 https://velog.io/@velopert/react-code-splitting SCSS https://www.joshwcomeau.com/css/custom-css-reset/ 2022 CSS Reset 다시 써보기! [css-real] 드래그(drag) 막기 ","date":"12 November 2022","permalink":"/posts/work/3/","section":"Posts","summary":"코드 스플리팅 # 리액트에서 활용 가능한 여러 방식의 코드 스플리팅이 있지만 우선 회사의 다른 프로젝트에서 사용하고 있는 loadable component를 활용한 페이지(라우팅) 기반의 코드 스플리팅만 적용 했다.","title":"[프로젝트 초기 설정] 코드 스플리팅 \u0026 SASS"},{"content":"","date":"12 November 2022","permalink":"/tags/sass/","section":"Tags","summary":"","title":"sass"},{"content":"배경 # 다른 팀원들이 기존 업무로 바빴기 때문에 신규 B2B 프로젝트에 나만 우선 투입되었다. (\u0026ldquo;곧 신규 프로젝트를 시작할 것이고 이 신규 프로젝트를 주도적으로 이끌어 나갈 수 있을 것이다.\u0026ldquo;라고 면접 때 들었고 이것이 내가 이 회사를 선택한 주된 이유 중 하나이기도 해서 매우 기대가 됨) 효율적인 협업을 위해 eslint(linter)와 prettier(formatter)로 코드 스타일을 맞추고 이를 효율적으로 확실히 지키기 위해 lint-staged(변경된 파일만 lint 검사)와 husky(git hook 공유)를 사용했다.\n1) 프로젝트 시작 # yarn create-react-app [project name] --template typescript 2) ESLint와 Prettier 적용 # yarn add eslint prettier eslint-config-prettier eslint-plugin-import @typescript-eslint/parser eslint-import-resolver-typescript -D npx eslint --init ✔ How would you like to use ESLint? · problems ✔ What type of modules does your project use? · esm ✔ Which framework does your project use? · react ✔ Does your project use TypeScript? · No / Yes ✔ Where does your code run? · browser ✔ What format do you want your config file to be in? · JSON The config that you\u0026#39;ve selected requires the following dependencies: eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest ✔ Would you like to install them now? · No / Yes ✔ Which package manager do you want to use? · yarn .eslintrc.json\r{ \u0026#34;env\u0026#34;: { \u0026#34;browser\u0026#34;: true, \u0026#34;es2021\u0026#34;: true }, \u0026#34;extends\u0026#34;: [ \u0026#34;eslint:recommended\u0026#34;, \u0026#34;plugin:react/recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;plugin:import/typescript\u0026#34;, \u0026#34;plugin:import/recommended\u0026#34;, \u0026#34;prettier\u0026#34; ], \u0026#34;overrides\u0026#34;: [], \u0026#34;parser\u0026#34;: \u0026#34;@typescript-eslint/parser\u0026#34;, \u0026#34;parserOptions\u0026#34;: { \u0026#34;ecmaVersion\u0026#34;: \u0026#34;latest\u0026#34;, \u0026#34;sourceType\u0026#34;: \u0026#34;module\u0026#34; }, \u0026#34;plugins\u0026#34;: [\u0026#34;react\u0026#34;, \u0026#34;react-hooks\u0026#34;, \u0026#34;@typescript-eslint\u0026#34;], \u0026#34;settings\u0026#34;: { \u0026#34;import/resolver\u0026#34;: { \u0026#34;node\u0026#34;: {}, \u0026#34;typescript\u0026#34;: { \u0026#34;directory\u0026#34;: \u0026#34;./src\u0026#34; } }, \u0026#34;import/parsers\u0026#34;: { \u0026#34;@typescript-eslint/parser\u0026#34;: [\u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;] } }, \u0026#34;rules\u0026#34;: { \u0026#34;react/react-in-jsx-scope\u0026#34;: 0, \u0026#34;import/order\u0026#34;: [ \u0026#34;error\u0026#34;, { \u0026#34;groups\u0026#34;: [ \u0026#34;builtin\u0026#34;, \u0026#34;external\u0026#34;, \u0026#34;internal\u0026#34;, [\u0026#34;parent\u0026#34;, \u0026#34;sibling\u0026#34;, \u0026#34;index\u0026#34;], \u0026#34;type\u0026#34;, \u0026#34;unknown\u0026#34; ], \u0026#34;pathGroups\u0026#34;: [ { \u0026#34;pattern\u0026#34;: \u0026#34;./*.scss\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;type\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;after\u0026#34; } ], \u0026#34;alphabetize\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;caseInsensitive\u0026#34;: true }, \u0026#34;newlines-between\u0026#34;: \u0026#34;always\u0026#34; } ], \u0026#34;react-hooks/rules-of-hooks\u0026#34;: 2, \u0026#34;react-hooks/exhaustive-deps\u0026#34;: 2, \u0026#34;import/export\u0026#34;: 0, \u0026#34;import/no-unresolved\u0026#34;: 0, \u0026#34;eslint-disable-next-line\u0026#34;: 0, \u0026#34;import/no-named-as-default-member\u0026#34;: 0 } } .prettierrc.json\r{ \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;css\u0026#34;, \u0026#34;insertPragma\u0026#34;: false, \u0026#34;jsxBracketSameLine\u0026#34;: false, \u0026#34;jsxSingleQuote\u0026#34;: false, \u0026#34;printWidth\u0026#34;: 80, \u0026#34;proseWrap\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;quoteProps\u0026#34;: \u0026#34;as-needed\u0026#34;, \u0026#34;requirePragma\u0026#34;: false, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: false, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;useTabs\u0026#34;: false, \u0026#34;vueIndentScriptAndStyle\u0026#34;: false } 3) Lint-Staged와 Husky 적용 # npx mrm lint-staged package.json\r{ ..., \u0026#34;lint-staged\u0026#34;: { \u0026#34;*.{js,jsx,ts,tsx}\u0026#34;: [ \u0026#34;prettier --write\u0026#34;, \u0026#34;eslint --fix\u0026#34; ] } } npx husky-init .husky/pre-commit\r#!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; yarn lint-staged ❗️node_modules를 재설치 할 경우 다시 해줘야 함\n","date":"11 November 2022","permalink":"/posts/work/2/","section":"Posts","summary":"배경 # 다른 팀원들이 기존 업무로 바빴기 때문에 신규 B2B 프로젝트에 나만 우선 투입되었다.","title":"[프로젝트 초기 설정] 협업 준비"},{"content":"","date":"11 November 2022","permalink":"/tags/convention/","section":"Tags","summary":"","title":"convention"},{"content":"","date":"11 November 2022","permalink":"/tags/eslint/","section":"Tags","summary":"","title":"eslint"},{"content":"","date":"11 November 2022","permalink":"/tags/husky/","section":"Tags","summary":"","title":"husky"},{"content":"","date":"11 November 2022","permalink":"/tags/lint-staged/","section":"Tags","summary":"","title":"lint-staged"},{"content":"","date":"11 November 2022","permalink":"/tags/prettier/","section":"Tags","summary":"","title":"prettier"},{"content":"","date":"11 November 2022","permalink":"/tags/typescript/","section":"Tags","summary":"","title":"typescript"},{"content":"배경 # 제품 상세페이지의 제품 이미지 바로 아래에 해당 제품의 평균 별점이 보이면 좋겠다는 의견이 나와서 이를 반영하기로 했다. 리뷰에 이미 평균 별점을 보여주는 기능이 적용되어 있었지만 별이 정수 단위로만 채워지고 있어서(예시. 4.3점이면 네 개, 4.5점이면 다섯 개) 소수점까지 정확히 반영되는 별점을 만들고 싶었다.\n시행착오 # 처음에는 별 5개가 나란히 있는 이미지를 받은 다음 아래에는 비어있는 별을, 위에는 채워져 있는 별을 겹쳐서 배치한 다음 채워져 있는 별의 부모 요소 넓이를 백분율에 따라 줄이고 overflow: hidden; 스타일을 적용하는 것으로 쉽게 구현했었다. 하지만 별 사이의 간격까지 백분율에 반영해 버리는 문제점을 지니고 있었다.\n구현 # 문제점을 해결하기 위해서 별 하나하나를 정수로 구분하고 별 내부를 소수점으로 구분하는 방법을 사용했다. 그리고 소수점 단위의 스타일 적용을 sass에서 구현하기 위해서 https://www.sassmeister.com/ 사이트를 참조해가며 반복문을 작성했다. (styled-component의 props가 잠시 그리워지는 시점이었다.) 마지막으로 별의 일부만 채우는 기능을 구현하기 위해 \u0026lt;svg/\u0026gt;에 margin-left: ...;를 마이너스 단위로 줘서 이동시킨 다음 내부의 \u0026lt;path/\u0026gt;를 transform: translateX(...);로 다시 이동시키는 방법을 사용했다.\n별점 리뷰 컴포넌트\rimport { StarSvg } from \u0026#34;src/assets/index\u0026#34;; import styles from \u0026#34;./StarReview.module.scss\u0026#34;; interface IStarsProps { score: number | undefined; size: string; emptyColor: string; filledColor: string; } /** * 5점 만점의 별점 리뷰 컴포넌트 `★★★★☆` * @score 별점(1~5점) e.g. `4.3` * @size 크기 e.g. `4vw` * @emptyColor 비었을 때 색상 e.g. `\u0026#34;#EEEDEF\u0026#34;` * @filledColor 찼을 때 색상 e.g. `\u0026#34;#6435C7\u0026#34;` */ export default function StarReview({ score, size, emptyColor, filledColor, }: IStarsProps) { const arr = new Array(5).fill(0); const _score = score || 0; const integer = Math.floor(_score); const decimal = Number((Number(_score.toFixed(1)) - integer).toFixed(1)) * 10; return ( \u0026lt;div className={styles.container}\u0026gt; \u0026lt;div className={styles.stars}\u0026gt; {arr.map((_, i) =\u0026gt; ( \u0026lt;StarSvg width={size} height={size} fill={emptyColor} key={i} /\u0026gt; ))} \u0026lt;/div\u0026gt; {!_score || _score \u0026lt; 1 || _score \u0026gt; 5 ? null : ( \u0026lt;div className={styles.stars} data-type=\u0026#34;filled\u0026#34;\u0026gt; {arr.map((_, i) =\u0026gt; ( \u0026lt;div key={i} data-decimal={decimal} data-index={i === integer ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;} data-empty={i \u0026gt; integer ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;} \u0026gt; \u0026lt;StarSvg width={size} height={size} fill={filledColor} /\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ); } 별점 리뷰 스타일\r.container { position: relative; .stars { display: flex; gap: 4px; \u0026amp;[data-type=\u0026#34;filled\u0026#34;] { top: 0; position: absolute; @for $i from 0 through 9 { \u0026gt; div[data-decimal=\u0026#34;#{$i}\u0026#34;][data-index=\u0026#34;true\u0026#34;] \u0026gt; svg { margin-left: -(100% - percentage($i * 0.1)); \u0026gt; path { transform: translateX(100% - percentage($i * 0.1)); } } } \u0026gt; div[data-empty=\u0026#34;true\u0026#34;] \u0026gt; svg { display: none; } } } } 별 이미지 (svg)\r\u0026lt;svg width=\u0026#34;current\u0026#34; height=\u0026#34;current\u0026#34; viewBox=\u0026#34;0 0 16 16\u0026#34; fill=\u0026#34;none\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; \u0026gt; \u0026lt;path d=\u0026#34;M7.71663 0.815216C7.81002 0.546548 8.18998 0.546548 8.28337 0.815216L9.81237 5.21396C9.85357 5.33248 9.96418 5.41284 10.0896 5.4154L14.7456 5.51028C15.0299 5.51608 15.1474 5.87744 14.9207 6.04928L11.2097 8.86273C11.1097 8.93854 11.0675 9.06857 11.1038 9.18867L12.4524 13.6461C12.5347 13.9183 12.2273 14.1416 11.9939 13.9792L8.17135 11.3192C8.06836 11.2476 7.93164 11.2476 7.82865 11.3192L4.00614 13.9792C3.77267 14.1416 3.46527 13.9183 3.54764 13.6461L4.89617 9.18867C4.9325 9.06857 4.89025 8.93854 4.79027 8.86273L1.0793 6.04928C0.852639 5.87744 0.970053 5.51608 1.25443 5.51028L5.91037 5.4154C6.03582 5.41284 6.14643 5.33248 6.18763 5.21396L7.71663 0.815216Z\u0026#34; fill=\u0026#34;current\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; export { ReactComponent as StarSvg } from \u0026#34;./star.svg\u0026#34;; *CRA 시에만 ReactComponent 사용 가능\n주의사항 # 해당 코드를 다른 프로젝트에 적용할 때 제대로 적용되지 않는 문제가 발생했다. 문제를 해결하기 위해 개발자 모드에서 스타일을 하나하나 꺼보면서 원인을 파악했다. 원인은 문제가 발생하는 프로젝트에 전역으로 text-align: center; 스타일이 먹혀있는 것이었다. 이 경험 덕에 전역으로 스타일을 먹이는 것은 위험하다는 것과 svg도 text-align이 먹힌다는 것을 배웠다.\n참조 # 출근 첫날 회사의 코드를 살펴보는 과정에서 이 코드를 보고는 \u0026ldquo;이런 식으로 sass에서 반복문을 활용하는구나\u0026quot;를 알게 되었고 메모장에 메모해 뒀었다. (취업 전에는 styled-component와 tailwind-CSS를 주로 사용해서 sass에 대한 이해도가 상대적으로 부족했다.) 그리고 별점의 소수점을 어떻게 sass에서 반영할 수 있을까를 고민하는 과정에서 이 코드가 떠올랐고 이를 참조해서 문제를 쉽게 해결할 수 있었다.\n$spacesPx: (2, 4, 6, 8, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100); @each $space in $spacesPx { .mt#{$space} { margin-top: #{$space}px; } .mr#{$space} { margin-right: #{$space}px; } .mb#{$space} { margin-bottom: #{$space}px; } .ml#{$space} { margin-left: #{$space}px; } } ","date":"5 November 2022","permalink":"/posts/work/1/","section":"Posts","summary":"배경 # 제품 상세페이지의 제품 이미지 바로 아래에 해당 제품의 평균 별점이 보이면 좋겠다는 의견이 나와서 이를 반영하기로 했다.","title":"평균 별점 (소수점 반영)"},{"content":"","date":"31 October 2022","permalink":"/categories/%5Cetc/","section":"Categories","summary":"","title":"\\etc"},{"content":"","date":"31 October 2022","permalink":"/tags/error/","section":"Tags","summary":"","title":"error"},{"content":"","date":"31 October 2022","permalink":"/tags/git/","section":"Tags","summary":"","title":"git"},{"content":"배경 # 취업을 하게 되면서 컴퓨터 두 대(개인 컴퓨터와 회사 컴퓨터)를 이용해 블로깅을 하게 되었고, 이 과정에서 서브 모듈 관련 문제를 만났다.\n문제 # blog 저장소에는 블로그 설정, 테마 등의 모든 요소가 저장되고 yuchanjeong.github.io 저장소에는 빌드 된 정적 파일들만 저장되고 있다. blog 저장소에서 블로그에 관한 모든 것들을 관리하고 yuchanjeong.github.io 저장소는 서브 모듈로 관리하고 있는데 git clone을 한 뒤 push를 했을 때 blog 저장소에는 정상적으로 반영이 되나 yuchanjeong.github.io 저장소에는 전혀 반영이 되지 않는 문제가 발생했다.\n해결 # 문제의 원인은 일반 클론 시 서브 모듈까지 클론하지 않기 때문이었다. 그래서 git clone --recurse-submodules를 통해 서브 모듈까지 클론해 줬다. 하지만 여전히 문제가 해결되지 않았고, cd public을 통해 서브 모듈로 이동한 뒤 확인해 보자 서브 모듈의 현재 브랜치가 main이 아니었다. 그래서 서브 모듈의 브랜치를 main으로 변경해 주자 문제가 해결되었다.\n*만약 기존 폴더를 그대로 사용한다면 git pull origin main --rebase를 통해 변경사항을 당겨 받은 뒤 서브 모듈로 이동해 git pull origin main -f를 통해 서브 모듈의 변경사항도 당겨 받으면 된다.\nEtc # 서브 모듈 등록 git submodule add -b main https://github.com/YuchanJeong/yuchanjeong.github.io.git public 원격 저장소의 서브 모듈로 업데이트 하기 git submodule update --remote 스크립트의 개행 제거 vi -b up.sh :%s/control+v -\u0026gt; control+m//g ","date":"31 October 2022","permalink":"/posts/etc/1/","section":"Posts","summary":"배경 # 취업을 하게 되면서 컴퓨터 두 대(개인 컴퓨터와 회사 컴퓨터)를 이용해 블로깅을 하게 되었고, 이 과정에서 서브 모듈 관련 문제를 만났다.","title":"깃허브 블로그 서브 모듈 문제"},{"content":"","date":"29 October 2022","permalink":"/categories/%5Cbooks/","section":"Categories","summary":"","title":"\\books"},{"content":"","date":"29 October 2022","permalink":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%80%EC%93%B0%EA%B8%B0/","section":"Tags","summary":"","title":"개발자의 글쓰기"},{"content":" 개발자의 글쓰기는 \u0026lsquo;정확\u0026rsquo;하고 \u0026lsquo;간결\u0026rsquo;하고 \u0026lsquo;가독성\u0026rsquo;이 높아야 한다.\n1) 기초 # 두괄식 - 핵심 설명 후 부가 설명 구조화 - 들여쓰기 활용 Ps1. 함수명에 사용하는 영단어 뉘앙스 차이\nstop(중지) / restart(재개) end(종료) / start(시작) finish(완전 종료) / pause(일시 중지) / hold(의도를 지닌 중지) get(획득) / retrieve(검색 후 획득) / acquire(독점 획득) / fetch(다음 대상 획득) set(할당) / init(초기값 할당) create(틀을 만듦) / register(만들어진 틀에 입력) change(내용 변화) / modify(틀린 내용 수정) / revise(새로운 내용으로 개정) do(행동) / must(필수) / should(권고) is(boolean 데이터) Ps2. \u0026ldquo;-조사\u0026rdquo;, \u0026ldquo;-하다\u0026rdquo;, \u0026ldquo;숫자-\u0026rdquo;, \u0026ldquo;-기호-\u0026ldquo;만 붙여 쓰고 나머지는 띄어 씀\n2) 네이밍과 주석 # 기본적인 네이밍 컨벤션 클래스와 컴포넌트 - PascalCase\n함수와 변수 - camelCase\n상수 - UPPER_DELIMITER_CASE\n패키지와 모듈 - lowercase 명사+명사+명사 (변수) 형용사+명사+명사 (변수) 동사+명사+명사 (함수) BEM 클래스 표기법 - 대상__요소\u0026ndash;상태 변수명 명확한 의미(E.g. d, day(X) -\u0026gt; today, someday(O)) 복수형은 짧을 때는 \u0026ldquo;-s\u0026rdquo;, 길 때는 \u0026ldquo;listOf-\u0026ldquo;나 \u0026ldquo;arrayOf-\u0026ldquo;로 표현 함수명 필요한 기능을 문장으로 작성 함수는 시스템이 할 일이기 때문에 사용자가 할 일은 삭제 중복 내용을 삭제하며 문장 정리 후 분리 1함수 1기능 원칙으로 문장 재분리 기능별 함수 작성 이름이 기능을 명확하게 설명해야 함 설명이 안될 경우 함수를 더 분리해야 함 좋은 이름의 기준 SMART Easy to Search 고전적 범주화 E.g. userBuyer, userPayer, userRegister Easy to Mix 상위 태그와 조합 E.g. h1.title, h2.title, p.title Easy to Agree 구별할 필요가 없는 것까지 이름을 새로 지을 필요 없음 Easy to Remember 이미 널리 알려진 용어는 그냥 쓰는 것이 효율적 Easy to Type 입력하기 쉽고 오타를 낼 가능성이 적은 이름 주석 코드는 의미를, 주석은 의도를 주석은 디버깅으로 바로 잡을 수 없으니 개발자가 신경 써야 함 3) 에러 메시지와 선택지 # 에러의 내용, 원인, 해결법을 알려 줘야 함 \u0026ldquo;예 / 아니오\u0026rdquo; 보다는 구체적인 선택지를 제시 E.g. \u0026ldquo;페이지에 머물기 / 페이지에서 나가기\u0026rdquo; 순서에 일관성이 있어야 함 비활성화를 활용해 에러 예방 가능 4) 릴리스 문서와 장애 보고서 # a. 릴리즈 문서\n선정: 회사와 개발자가 말하고 싶은 것과 독자가 듣고 싶은 것 중 두 개 이상 만족하는 것 선정 분류: 독자에 따라 \u0026ldquo;개발 관점에서 비슷한 내용\u0026rdquo; 혹은 \u0026ldquo;사용 관점에서 비슷한 내용\u0026quot;으로 분류 요약: 불필요한 부사, 형용사, 조사, 어미 제거 종합: 종합은 분석의 개념화와 반대로 특징이나 결과로 서술 Ps. Semantic Versioning - major(호환 X).minor(새로운 기능).patch\nb. 장애 보고서\n문제, 문제점, 해결책, 후순 계획 순서로 작성 면책 조항 필수 필수, 권장, 선택, 예외 사항 표기 장애 보고서 구성 장애 내용 장애 영향 장애 원인 조치 사항 조치 결과 핵심 원인 향후 대책 장애의 근본 원인을 찾기 위해 원인의 원인을 계속 찾아라(5 whys) 재발을 막기 위해서는 원인 대신 이유를 묻고 사람 주어로 대답하라 개발 관점은 기능이 작동하지 않은 것, 비즈니스 관점은 손실이 발생한 것 모호하게 말고 정확한 정보를 적어라(E.g. 재발 가능성 30%) 5) 개발 가이드 # 서비스 개념을 범주, 용도, 특징으로 설명하라 용도는 범주의 핵심 기능을 써라 특징은 장점(자신 기준)과 강점(경쟁사와 비교)에서 뽑아 써라 이해를 돕기 위해 그림과 글로 묘사해라 주관적 묘사와 객관적 묘사를 둘 다 써라 의견을 쓰려면 근거를 대라 주장과 이유, 문제와 답의 거리를 좁혀라 순서에서 단계를 단계에서 목차를 만들어라 6) SI 제안서 # 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 탁월할 때, 경쟁사와 비교하여 강점들을 제안하라 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 부족할 때, 일단 동감하고 경쟁사와 다른 방안을 제시하라 고객의 문제인식이 사소하고 제안사의 문제 해결 능력이 탁월할 때, 고객이 문제를 중대하게 인식하게 만들어라 고객의 문제인식이 사소하고 제안사의 문제 해결 능력이 부족할 때, 경쟁사의 전략을 확인해서 대처하라 요구사항을 분석하지말고 제시하라 변화하는 요구사항에 대비하라 - Two Track(전체 검수와 기능별 검수) 개발 시간 대비 고객의 예상 만족도가 높은 것 위주로 개발하라 7) 기술 블로그 # 주제 의식을 버리고 소재 의식으로 쓰자 독자 수준이 아니라 자기 수준으로 쓰자 저 직접 경험하고 실험한 과정이나 결과*목차를 잘 잡고 본문부터 써라 술 어떤 것을 분석하여 의미를 풀이하고 해석한 것*원전을 비교하고 실험해 풀이해서 써라 편 산만하고 복잡한 자료를 편집해 질서를 부여한 것*순서를 요약해서 써라 집 여러 사람의 견해나 흩어진 자료를 한데 모아 정리한 것*자료를 모아 핵심을 엮어 써라 ","date":"29 October 2022","permalink":"/posts/books/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%80%EC%93%B0%EA%B8%B0/","section":"Posts","summary":"개발자의 글쓰기는 \u0026lsquo;정확\u0026rsquo;하고 \u0026lsquo;간결\u0026rsquo;하고 \u0026lsquo;가독성\u0026rsquo;이 높아야 한다.","title":"개발자의 글쓰기 - 김철수"},{"content":"","date":"29 October 2022","permalink":"/tags/%EA%B9%80%EC%B2%A0%EC%88%98/","section":"Tags","summary":"","title":"김철수"},{"content":"","date":"1 January 0001","permalink":"/categories/%5Csummaries/","section":"Categories","summary":"","title":"\\summaries"},{"content":"1) 기본 설정 # Command Details git init 깃 추적 시작 git config --global --list 기본 설정 보기 git config --global core.autocrlf true 개행문자 설정 git config --global user.name YuchanJeong 사용자 이름 설정 git config --global user.email yuchanjeong0923@gmail.com 사용자 메일 설정 git config --global core.editor vim 기본 에디터 설정 git config --global init.defaultBranch main 기본 브랜치 설정 git config --global commit.template ~/.gitmessage.txt 커밋 템플릿 설정 .vimrc\rset nocompatible \u0026#34; 오리지날 VI와 호환하지 않음 set autoindent \u0026#34; 자동 들여쓰기 set cindent \u0026#34; C 프로그래밍용 자동 들여쓰기 set smartindent \u0026#34; 스마트한 들여쓰기 set wrap set nowrapscan \u0026#34; 검색할 때 문서의 끝에서 처음으로 안돌아감 set nobackup \u0026#34; 백업 파일을 안만듬 set noswapfile \u0026#34;set visualbell \u0026#34; 키를 잘못눌렀을 때 화면 프레시 set ruler \u0026#34; 화면 우측 하단에 현재 커서의 위치(줄,칸) 표시 set shiftwidth=4 \u0026#34; 자동 들여쓰기 4칸 set number \u0026#34; 행번호 표시, set nu 도 가능 set fencs=ucs-bom,utf-8,euc-kr.latin1 \u0026#34; 한글 파일은 euc-kr로, 유니코드는 유니코드로 set fileencoding=utf-8 \u0026#34; 파일저장인코딩 set tenc=utf-8 \u0026#34; 터미널 인코딩 \u0026#34;set expandtab \u0026#34; 탭대신 스페이스 set hlsearch \u0026#34; 검색어 강조, set hls 도 가능 set ignorecase \u0026#34; 검색시 대소문자 무시, set ic 도 가능 set tabstop=4 \u0026#34; 탭을 4칸으로 set lbr set incsearch \u0026#34; 키워드 입력시 점진적 검색 set cursorline \u0026#34; 편집 위치에 커서 라인 설정 set laststatus=2 \u0026#34; 상태바 표시를 항상한다 syntax on \u0026#34; 구문강조 사용 filetype indent on \u0026#34; 파일 종류에 따른 구문강조 set background=dark \u0026#34; 하이라이팅 lihgt / dark set backspace=eol,start,indent \u0026#34; 줄의 끝, 시작, 들여쓰기에서 백스페이스시 이전줄로 set history=1000 \u0026#34; vi 편집기록 기억갯수 .viminfo에 기록 highlight Comment term=bold cterm=bold ctermfg=4 \u0026#34; 코멘트 하이라이트 set mouse=a \u0026#34; vim에서 마우스 사용 set t_Co=256 \u0026#34; 색 조정 2) 원격 저장소 # Command Details git remote -v 원격 저장소 연결 확인 git remote add [name] [url] 원격 저장소 연결 git remote remove [name] 원격 저장소 연결 해제 git push [name] [branch] (-f) 원격 저장소에 Push (강제) git pull [name] [branch] (--rebase) 원격 저장소 Pull (이어 붙히기) git clone [url] ([directory]) 원격 저장소 복사 (폴더명) 3) 파일 상태 # Command Details git status 파일 상태 확인 git diff 파일 상태 비교*작업역역과 스테이지 차이 git diff --cached 파일 상태 비교*스테이지와 저장소 차이 git diff [commit] [commit] 커밋 간 상태 비교 git diff [branch] [branch] 브랜치 간 상태 비교 4) 스테이징 (추가) # Command Details git add -p 변경 내용을 확인 후 청크 별로 추가*y(추가), n(제외), q(종료) git add [directory] 해당 폴더 및 하위 폴더의 변경 내용을 추가 git add . 현재 폴더 및 하위 폴더의 변경 내용을 추가 5) 커밋 (확정) # Command Details git commit 커밋 생성 git commit -m \u0026ldquo;[msg]\u0026rdquo; 커밋 메시지와 함께 커밋 생성 git commit -am \u0026ldquo;[msg]\u0026rdquo; 스테이징 후 커밋 메시지와 함께 커밋 생성 *한 번 이상 커밋 한 파일만 가능 git commit --amend 마지막 커밋 메시지 수정 6) 커밋 기록 # Command Details git log 커밋 기록 보기 git log -p 커밋 기록과 패치내용 보기 git log --stat 커밋 기록과 패치통계 보기 git log --graph 커밋 기록과 그래프 보기 git log [branch]..[branch] 후자에만 있는 커밋 기록 보기 7) 되돌리기 # Command Details git reset --hard [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋, 스테이징, 작업 초기화 git reset [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋, 스테이징 초기화 git reset --soft [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋 초기화 git revert [commit] 해당 커밋의 수정사항 취소 후 새 커밋 생성 git revert [commit]..[commit] 해당 범위의 수정사항 취소 후 새 커밋 생성 git rebase -i [commit] | HEAD[~n] p: 커밋 그냥 사용, 재정렬 및 삭제 가능r: 커밋 메시지 수정e: 커밋 메시지 및 내용 수정*HEAD가 해당 커밋으로 이동, 추가 작업 가능*git rebase --continue (작업 종료)*git rebase --abort (작업 중단)s: squash merged: 커밋 삭제 8) 임시 저장 # Command Details git stash (-u) 임시 저장 후 직전 커밋 상태로 되돌아감 (새 파일도)*한 번 이상 스테이징 한 파일만 가능 git stash list 임시 저장 목록 보기 git stash apply (stash@{[n]}) 최근(해당) 임시 저장 상태로 돌아가기 git stash drop (stash@{[n]}) 최근(해당) 임시 저장 상태 지우기 git stash pop 최근 임시 저장 상태 apply 후 drop 9) 브랜치 # Command Details git branch (-a) 브랜치 목록 보기 (원격 목록도) git branch [branch] 브랜치 생성 git branch -d [branch] 해당 브랜치 삭제 git branch -m [branch] [branch] 브랜치명 바꾸기 git checkout [branch] 브랜치 전환 git checkout -b [branch] 브랜치 생성 후 전환 git merge [branch] (--squash) 현재 브랜치에 해당 브랜치 병합 (스쿼시 병합) git rebase [branch] 현재 브랜치에 해당 브랜치 이어 붙이기 10) 삭제 # Command Details git rm (--cached) [file] 해당 파일 삭제 (원격에서만) git rm -r (--cached) [directory] 해당 폴더 삭제 (원격에서만) git fetch --all --prune 원격 브랜치 흔적 삭제 Etc # 1) .gitignore # List Details example.xxx 해당 파일명 전부 제외 /example.xxx 현재 폴더의 해당 파일 제외 example/ 해당 폴더와 하위 경로 제외 example/example.xxx 해당 폴더의 해당 파일 제외 *.xxx 특정 확장자 파일 전부 제외 !example.xxx 예외 파일명 (버전 관리 ON) 2) SSH 등록 # ssh-keygen으로 ~/.ssh/에 id_rsa.pub(공개키)와 id_rsa(개인키) 생성 공개키를 Github의 Settings/SSH and GPG keys에 등록 3) Github 계정 오류 # 키체인 접근 -\u0026gt; github.com ","date":"1 January 0001","permalink":"/posts/summaries/git/","section":"Posts","summary":"1) 기본 설정 # Command Details git init 깃 추적 시작 git config --global --list 기본 설정 보기 git config --global core.","title":"Git"},{"content":"","date":"1 January 0001","permalink":"/tags/javascript/","section":"Tags","summary":"","title":"javascript"},{"content":"JS Data # 1. Type # Data Type Details string - 쌍따음표(\u0026quot;\u0026quot;)나 따음표(\u0026rsquo;\u0026rsquo;)로 감싸서 표현\n- Template literals(`${변수}`)로 변수 사용 가능\n- +로 합치기 가능(이때 다른 타입은 문자화)\n- str[n]으로 character 읽기 가능(read only)\n- String(data), data.toString()으로 문자화 가능\n*Escape Sequence\nㅤ└ \\n (new line)\nㅤ└ \\t (tap) number - Number(str)로 숫자화 가능\nㅤ*숫자가 아닌 문자열이 있으면 NaN\n- parseInt(str)로 정수화 가능, parseFloat(str)으로 숫자화 가능\nㅤ*숫자가 아닌 문자열이 뒤에 있으면 숫자인 부분까지 숫자화 boolean true | false array - 대괄호([])로 감싸서 표현\n- arr[i]로 element 읽기 가능\n- arr[i] = value로 arr의 i index에 value 할당 가능\n- new Array.from({ length: n })으로 n개의 undefined를 가진 배열 생성 가능\n- new Array(n).fill(element)로 n개의 element를 가진 배열 생성 가능 object - 중괄호({})로 감싸서 표현\n- odj.key와 obj[str]으로 value 읽기 가능\n- odj.key = value와 obj[str] = value로 obj의 key에 value (생성)할당 가능\n- delete obj[str]로 key-value 삭제 가능\n- str in obj로 key 존재 여부 판단 가능*Optional Chainingㅤ└ obj.key1?.key2는 key1이 있을 때만 key2 확인 null 의도적으로 비움 undefined 값이 할당되지 않음 falsy false, null, undefined, \u0026ldquo;\u0026rdquo;, 0, NaN (나머지는 truthy) typeof 평가 전 데이터 타입을 string으로 반환 function은 \u0026ldquo;function\u0026rdquo; undeclared variable은 \u0026ldquo;undefined\u0026rdquo; null과 array는 \u0026ldquo;object\u0026rdquo; null은 data === null로 판단 array는 Array.isArray(data)로 판단 NaN은 isNaN(number)으로 판단 2. Properties \u0026amp; Methods # 1) String # Properties \u0026 Methods Return str.length 문자열 안의 코드 유닛 수 str.indexOf(searchValue[, fromIndex]) searchValue의 첫 번째 등장 인덱스,\n찾을 수 없으면 -1\n*.lastIndexOf()는 마지막 등장 인덱스 str.includes(searchValue[, fromIndex]) searchValue를 포함하고 있는지 여부 str.slice(beginIndex[, endIndex]) 추출된 부분(~이상~미만)을 담는 새로운 string str.split([separator[, limit]]) separator(문자열|정규식)로 끊은 문자열들의 array str.match(regexp) 정규식과 일치하는 문자열을 포함하는 array,\n찾을 수 없으면 null\n*g옵션이 없을 때 캡처된 그룹 및 정보도 배열에 포함 str.replace(regexp|subStr, newSubStr|function) 패턴과 처음 일치하는 부분이 교체된 새로운 string\n*.replaceAll()은 모든 일치 문자 교체 str.toUpperCase()\nstr.toLowerCase() 모두 대문자로 바꾼 string\n모두 소문자로 바꾼 string str.trim() 양끝의 공백을 제거한 string 2) Number \u0026amp; Math # Properties \u0026 Methods Return num.toFixed([digits]) 고정 소수점 표기법을 사용하여 나타낸 수의 string\n*digits: 소수점 뒤에 나타날 자릿수, 기본값 0 Math.abs(x) 숫자의 절댓값 Math.max([x[, y[, …]]])\nMath.min([x[, y[, …]]]) 0개 이상의 인수 중에서 제일 큰 수\n0개 이상의 인수 중에서 제일 작은 수 Math.ceil(x)\nMath.floor(x)\nMath.round(x) 인수보다 크거나 같은 수 중에서 가장 작은 정수\n인수보다 작거나 같은 수 중에서 가장 큰 정수\n인수에 가장 가까운 정수 Math.sqrt(x) √x Math.pow(x, n) x의 n제곱값 Math.random() 0 이상 1 미만의 부동소수점 의사 난수 3) Array # Properties \u0026 Methods Return arr.length 배열 안의 요소 수\n*arr.length === 0은 빈 배열 arr.indexOf(searchValue[, beginIndex]) searchValue의 첫 번째 등장 인덱스,\n찾을 수 없으면 -1\n*.lastIndexOf()는 마지막 등장 인덱스 arr.includes(searchValue[, beginIndex]) searchValue를 요소로 포함하고 있는지 여부 arr.slice(beginIndex[, endIndex]) 추출된 부분(~이상~미만)을 담는 array arr.join([separator]) 모든 요소를 separator로 구분지어 연결한 string\n*separator를 생략하면 쉼표(,)로 구분 arr.concat([value1[, ...[, valueN]]]) 콜백 배열이나 값들을 기존 배열에 합친 array arr.forEach(callback(currentValue\n[, index[, array]])[, thisArg]) undefined\n*콜백 함수를 각 요소에 대해 실행 arr.map(callback(currentValue\n[, index[, array]])[, thisArg]) 콜백 함수를 각 요소에 대해 실행한 결과의 array arr.filter(callback(currentValue\n[, index[, array]])[, thisArg]) 콜백 함수의 결과가 참인 요소의 array arr.find(callback(currentValue\n[, index[, array]])[, thisArg]) 콜백 함수의 결과가 참인 요소 중 첫 번째 item,\n찾을 수 없으면 undefined arr.findIndex(callback(currentValue\n[, index[, array]])[, thisArg]) 콜백 함수의 결과가 참인 요소 중 첫 번째 요소의 인덱스,\n찾을 수 없으면 -1 arr.reduce(callback(accValue[, curValue\n[, curIndex[, array)[, initialValue]]]]) 콜백 함수의 누적 결과 값(last accValue)\n*initialValue는 첫 accValue의 값이며,\n생략 시 arr[0]이 첫 accValue, arr[1]이 첫 curValue arr.sort([compareFunction]) 정열된 array(원본) arr.reverse() 순서가 반전된 array(원본) arr.splice(beginIndex[, deleteCount\n[, item1[, ...[, itemN]]]]) 제거한 요소를 담은 array\n*배열(원본)의 요소를 교체\n*deleteCount를 생략하면 배열(원본)의 마지막까지 삭제 arr.push(item1[, ...[, itemN]]) 요소가 추가된 배열의 새로운 length\n*배열(원본)의 끝에 하나 이상의 요소를 추가\n*.unshift()는 배열(원본)의 앞에 추가 arr.pop(item1[, ...[, itemN]]) 배열의 마지막 item\n*배열(원본)의 마지막 요소 삭제\n*.shift()는 배열(원본)의 첫 번째 요소 삭제 arr.flat([depth]) depth 번 만큼 다차원 배열을 푼 array\n*depth의 기본값은 1 *beginIndex, endIndex의 값이 음수일 때, 끝에서부터의 위치를 의미 4) Object # Properties \u0026 Methods Return Object.assign(target, ...sources) 출처 객체들로부터 하나 이상의 속성들이 복사된 목표 object\n*동일한 키를 갖는 속성은 뒤의 출처 값으로 덮어쓰여짐 Object.keys(obj) 모든 속성의 키(문자열)를 반환한 array\n*Object.values(obj)는 값의 array Object.fromEntries(arr) [key, value] 형태의 다차원 배열을 변환한 object\n*Object.entries(obj)는 [key, value] 형태의 이차원 array Object.hasOwnProperty(key) 특정 프로퍼티를 가지고 있는지 여부 3. Etc # 1) Destructuring Assignment(구조 분해 할당)\n배열/객체의 속성을 해체 후 그 값을 개별 변수에 할당하는 표현식\nArray const arr = [1, 2, 3, 4, 5]; const [a, , b, ...rest] = arr; // a는 1, b는 3, rest는 [4, 5] Object const obj = { name: \u0026#34;X\u0026#34;, age: 10, gender: \u0026#34;male\u0026#34; }; const { name, gender: sex, address = \u0026#34;Korea\u0026#34; } = obj; // name는 \u0026#34;X\u0026#34;, sex는 \u0026#34;male\u0026#34;, address는 \u0026#34;Korea\u0026#34; 2) Spread Syntax(전개 구문)\n\u0026hellip;data의 형태로 문자열·배열·객체를 펼치는 표현식\nString const str = \u0026#34;Che\u0026#34;; // [...str]는 [\u0026#34;C\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;] // {...str}는 { \u0026#34;0\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;1\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;e\u0026#34; } Array const arr1 = [1, 2, 3]; // [...arr1]은 [1, 2, 3], !== arr1 // {...arr1}는 { \u0026#34;0\u0026#34;: 1, \u0026#34;1\u0026#34;: 2, \u0026#34;2\u0026#34;: 3 } const arr2 = [4, 5, 6]; // [...arr1, ...arr2]는 [1, 2, 3, 4, 5, 6] Object const obj = { a: 1, b: 2, c: 3 }; // {...obj1}은 { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3 }, !== obj1 const obj2 = { c: 1, d: 2, e: 3 }; // {...obj1, ...obj2}는 { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 1, \u0026#34;d\u0026#34;: 2, \u0026#34;e\u0026#34;: 3} Rest Prams const func = (team, ...members) =\u0026gt; ({ 팀: team, 멤버: members }); const myTeam = func(\u0026#34;KT\u0026#34;, \u0026#34;Smeb\u0026#34;, \u0026#34;Score\u0026#34;, \u0026#34;Ucal\u0026#34;, \u0026#34;Deft\u0026#34;, \u0026#34;Mata\u0026#34;); /* myTeam은 { 팀: \u0026#34;KT\u0026#34;, 멤버: [\u0026#34;Smeb\u0026#34;, \u0026#34;Score\u0026#34;, \u0026#34;Ucal\u0026#34;, \u0026#34;Deft\u0026#34;, \u0026#34;Mata\u0026#34;], }; */ 3) Immutability(불변성)\nPrimitive Type(원시 타입) string, number, boolean, undefined, null 변수에 값을 저장 immutable Reference Type(참조형 타입) array, object, function 변수에 heap의 주소를 저장, 값은 heap에 저장 같은 주소(heap)를 참조할 때 하나 변화 시 일괄 변화 mutable 4) Shallow Copy(얕은 복사) \u0026amp; Deep Copy(깊은 복사)\nShallow Copy 복사한 참조형 데이터 내부의 참조형 데이터는 같은 주소 참조 Deep Copy 복사한 참조형 데이터 내부의 참조형 데이터도 다른 주소 참조 JS Operator # 1) Ternary Operator(삼항 연산자)\n조건 ? 조건이 true일 때 : 조건이 false일 때 2) Logical Operator(논리 연산자)\nOperator Details \u0026\u0026 - and (모두 truthy일 때 true)\n- leftExpr \u0026\u0026 rightExpr\nㅤ└ leftExpr이 truthy일 때, rightExpr\nㅤ└ leftExpr이 falsy일 때, leftExpr || - or (하나라도 truthy일 때 true)\n- leftExpr || rightExpr\nㅤ└ leftExpr이 truthy일 때, leftExpr\nㅤ└ leftExpr이 falsy일 때, rightExpr ?? - leftExpr ?? rightExpr (nullish coalescing(널 병합))\nㅤ└ leftExpr이 null 혹은 undefined가 아닐 때, leftExpr ㅤ└ leftExpr이 null 혹은 undefined 때, rightExpr ! - not (falsy일 때 true) 3) Comparison Operator(비교 연산자)\nOperator Details a === b 값과 타입이 같을 때 true a !== b 값이나 타입이 다를 때 true a \u003e b a \u003e b일 때 true a \u003c b a \u003c b일 때 true a \u003e= b a \u003e= b일 때 true a \u003c= b a \u003c= b일 때 true 4) Arithmetic Operator(산술 연산자)\nOperator Details a + b 덧셈 a - b 뺄셈 a * b 곱셈 a / b 나눗셈 a % b 나머지 5) Assignment Operator(할당 연산자)\nOperator Details a += b a = a + b a -= b a = a - b a *= b a = a * b a /= b a = a / b a %= b a = a % b 6) Increment Operator(증감 연산자)\nOperator Details a++/-- 연산 후 1증가/감소 ++/--a 1증가/감소 후 연산 JS Control Statement # 1) Conditional Statement(조건문)\nif 조건문 if (조건1) { 조건1이 truthy일 때 } else if (조건n) { 조건n이 truthy일 때 } else { 조건이 모두 falsy일 때 } switch 조건문 switch (대상) { case 케이스n: 대상이 케이스n일 때 break; default: 해당 케이스가 없을 때 } 2) Iterative Statement(반복문)\nfor 반복문\nfor (초기값; 반복 조건; 증감값) { 반복내용; } // for of 배열 for (let item of iterator) { 반복내용; } // for in 객체 for (let key in object) { 반복내용; } while 반복문\nwhile (반복 조건) { 반복 내용 } Escape Details break 해당 반복문 종료 continue 해당 반복 내용을 종료하고 다음 반복으로 넘어감 label 해당 label의 반복문을 대상으로 함 outer: for (item of arr) { inner: for (el of item) { if (el === 0) { break outer; } if (el === 1) { continue inner; } } } JS Function # 1) 함수 작성\nNamed Function Declaration(기명 함수 선언)\nfunction 함수() {} 호이스팅 시 일시적 사각지대(코드 실행 전까지 초기화가 일어나지 않음)에 빠지지 않음 Anonymous Function Expression(익명 함수 표현)\nconst 변수 = function () {}; Arrow Function(화살표 함수)\nconst 변수 = () =\u0026gt; {}; 인자가 하나일 때, 인자의 소괄호 생략 가능 { return } 생략 가능 객체 데이터는 소괄호로 묶어야 함 메서드 함수로 적합하지 않음 생성자 함수로 사용할 수 없음 2) 고차 함수\nTimer Function(타이머 함수)\nType Details setImmediate(콜백) 즉시 함수 실행*setTimeout(콜백, 0) 사용은 지양 setTimeout(콜백, ms) 일정 시간 후 함수 실행 setInterval(콜백, ms) 일정 시간 마다 함수 실행 clearImmediate(타이머) 해당 Immediate 함수를 종료 clearTimeout(타이머) 해당 Timeout 함수를 종료 clearInterval(타이머) 해당 Interval 함수를 종료 Callback Function(콜백 함수)\n함수의 「인자」로 사용되는 함수 function timeout(cb) { setTimeout(() =\u0026gt; { console.log(\u0026#34;start\u0026#34;); // 함수의 실행 위치 보장 cb(); }, 1000); } timeout(() =\u0026gt; { console.log(\u0026#34;done\u0026#34;); }); Closure Function(클로저 함수)\n함수를 return하는 함수 외부 함수의 「변수」를 내부 함수에서 재사용 const makeCounter = (x) =\u0026gt; { // 함수 변경 없이 value에 할당 불가능 (캡슐화) let value = x; // 내부함수 여러개 생성 가능 return { // 스코프 체이닝 (하위 스코프 우선) up: (x) =\u0026gt; { value += x; return value; }, down: (y) =\u0026gt; { value -= y; return value; }, }; }; // 함수 재활용 가능 const counter1 = makeCounter(1); const counter2 = makeCounter(2); counter1.up(7); // -\u0026gt; 8 counter2.down(7); // -\u0026gt; -5 counter2.up(7); // -\u0026gt; 2 // counter1과 counter2의 value는 서로에게 영향 X Curry Function(커리 함수)\n함수를 return하는 함수 외부 함수의 「인자」를 내부 함수에서 재사용 const greeting = (x) =\u0026gt; { return (y) =\u0026gt; { return `${x} ${y}`; }; }; // 함수 재활용 가능 const hello = greeting(\u0026#34;Hello\u0026#34;); const goodMorning = greeting(\u0026#34;goodMorning\u0026#34;); hello(\u0026#34;guys\u0026#34;); // -\u0026gt; \u0026#39;Hello guys\u0026#39; hello(\u0026#34;ladies\u0026#34;); // -\u0026gt; \u0026#39;Hello ladies\u0026#39; goodMorning(\u0026#34;guys\u0026#34;); // -\u0026gt; \u0026#39;goodMorning guys\u0026#39; goodMorning(\u0026#34;ladies\u0026#34;); // -\u0026gt; \u0026#39;goodMorning ladies\u0026#39; JS Class # class 클래스 { constructor() {} } class 하위_클래스 extends 상위_클래스 { constructor() { super(); } } const 인스턴스 = new 클래스(); static : 클래스에서만 참조 및 호출 가능 # : 내부에서만 참조 및 호출 가능 example /* 1) 클래스 */ class Vehicle { //constructor: 클래스의 파라미터 constructor(name, wheel) { this.name = name; this.wheel = wheel; } //static static hi = \u0026#34;hi\u0026#34;; static isVehicle(vehicle) { return vehicle instanceof Vehicle; } //private #private = \u0026#34;private\u0026#34;; #saySecret() { console.log(this.#private); } //property bye = \u0026#34;bye\u0026#34;; //method beep() { this.#saySecret(); console.log(\u0026#34;beep!\u0026#34;); } } /* 2) 클래스 상속 */ class Car extends Vehicle { constructor(name, wheel, year) { //super: 상위 클래스의 파라미터 super(name, wheel); this.year = year; } getWheel() { this.beep(); console.log(`bye: ${this.bye}`); console.log(`wheel: ${this.wheel}`); } } /* 3) prototype */ // 공통 메서드 함수는 생성자의 prototype에 할당해서 메모리 절약 가능 // prototype chain : 해당 객체 -\u0026gt; 생성자 -\u0026gt; 상위 생성자 -\u0026gt; Object Vehicle.prototype.getInfo = function () { console.log(`${this.name}(${this.year})`); }; /* 4) 클래스로 인스턴스(객체) 생성 */ const myCar = new Car(\u0026#34;벤츠\u0026#34;, 4, \u0026#34;2016\u0026#34;); const yourCar = new Car(\u0026#34;BMW\u0026#34;, 4, \u0026#34;2020\u0026#34;); // ========== // Vehicle.hi; // \u0026#34;hi\u0026#34; Vehicle.isVehicle(myCar); // true myCar.bye; // \u0026#34;bye\u0026#34; myCar.beep; // -\u0026gt; private -\u0026gt; beep! myCar.getWheel(); // -\u0026gt; private -\u0026gt; beep! -\u0026gt; wheel: 4 myCar.getInfo(); // -\u0026gt; 벤츠(2016) yourCar.getInfo(); // -\u0026gt; BMW(2020) JS Asynchronous # 1) Promise\n실행은 되지었지만 아직 결과를 반환하지 않은 객체 resolve는 성공값으로 then으로 연결 reject는 실패값으로 catch로 연결 finally는 마지막에 무조건 실행 Promise changing then에서 반환한 값이 다음 then으로 넘어감 반환값이 프로미스면 resolve 후 넘어감 에러는 catch에서 한 번에 처리 여러 프로미스 동시 실행 Promise.all([promise, ...]) 하나라도 실패하면 catch로 이동 각 결과는 배열에 담겨서 반환 Promise.allSettled([promise, ...]) 실패가 있어도 catch로 이동하지 않음 각 결과는 status 프로퍼티를 가지고 status가 fulfilled인 경우 value 프로퍼티, rejected인 경우 reason 프로퍼티를 가짐 2) async/await\n프로미스 앞에 await을 붙히면, 해당 프로미스가 resolve될 때까지 기다린 뒤 다음 로직으로 넘어감 async 함수 내에서만 await 사용 가능 async 함수는 항상 프로미스 반환 try/catch로 에러 처리 for await (promise of [promise, ...])으로 반복 가능 JS Etc # 1. DOM # DOM(문서 객체 모델)은 메모리에 웹 페이지 문서 구조를 표현함으로써 스크립트 및 프로그래밍 언어와 페이지를 연결함\nMethods Details document.querySelector(\u0026ldquo;selector\u0026rdquo;) 문서 내에서 selector와 일치하는 첫 번째 요소 document.querySelectorAll(\u0026ldquo;selector\u0026rdquo;) 문서 내에서 selector와 일치하는 NodeList\n*NodeList[i]로 개별 요소 선택\n*for이나 forEach로 요소들 반복처리 document.createElement(\u0026ldquo;tag\u0026rdquo;) 문서 내에 해당 tag 요소 생성\n*아직 DOM tree에 연결 X .appendChild(aChild) 대상의 마지막 자식 노드로 붙임\n*DOM tree에 연결 .addEventListener(\u0026ldquo;event\u0026rdquo;, functionRef*) 이벤트 발생 시 함수 호출\n*event: click|focus|blur|scroll\n*event.target은 이벤트의 대상 요소 .onclick = functionRef* 대상 클릭 시 함수 호출 .classList\nㅤ.add(String [, String [, \u0026hellip;]])\nㅤ.remove(String [, String [, \u0026hellip;]])\nㅤ.contains(String) 클래스 추가\n클래스 삭제\n클래스 포함 여부 .setAttribute(\u0026ldquo;attribute\u0026rdquo;, \u0026ldquo;value\u0026rdquo;)\n.[attribute] = \u0026ldquo;value\u0026rdquo; 속성(HTML) 할당 .style.[property] = \u0026ldquo;value\u0026rdquo; 특성(CSS) 할당 .textContent = \u0026ldquo;content\u0026rdquo; 내용 할당\n*innerText(보안상 사용 금지)와 유사 .remove() 노드를 메모리에서 삭제 .removeChild(aChild) 대상과 자식 노드의 연결을 끊음 .children 자식 요소 목록\n*.firstElementChild는 첫 번째 자식\n*.lastElementChild는 마지막 자식 .parentsElement 부모 요소 *functionRef(Event Handler):\n함수의 실행이 아닌 함수 자체를 넣어야함 아무런 인자를 담지 않으면 event 객체만 전달 특정 인자를 전달하기 위해서는 콜백함수 사용\nㅤEx. eventHandler={(e) =\u0026gt; (param, \u0026hellip;, e) =\u0026gt; {}}; e.preventDefault(); (고유 동작을 막음) e.stopPropagation(); (이벤트 전파를 막음) if (e.target !== e.currentTarget) return; (해당 요소만 이벤트의 대상) 2. Scope \u0026amp; Declarations # Scope Details Global Scope window(브라우저의 객체)에 저장 Function Level Scope var중복 선언 가능 Block Level Scope letㅤ중복 선언 불가능ㅤ값의 재할당 가능constㅤ중복 선언 불가능ㅤ값의 재할당 불가능, 초기화 필수ㅤ참조형 데이터의 요소는 재할당, 추가, 삭제 가능ㅤ *하위 스코프 우선(Scope Chaining)\n*선언(호출 X)된 위치에 따라 상위 스코프 결정(Lexical Scoping)\n3. This # Type Condition Target 일반 함수 호출 1. 일반 호출: 전역 객체2. 메서드 호출: 호출 객체 화살표 함수 선언 화살표 함수를 감싸고 있는 외부 함수의 객체 example const obj1 = { normal: function () { console.log(this); }, arrow: () =\u0026gt; { console.log(this); }, }; obj1.normal(); // 메서드 호출, this === obj1 const obj11 = obj1.normal; obj11(); // 일반 호출, this === window obj1.arrow(); // this === { } // ========== // const obj2 = { normal: function () { setTimeout(function () { console.log(this); }, 1000); }, arrow: function () { setTimeout(() =\u0026gt; { console.log(this); }, 1000); }, }; obj2.normal(); // this === window // obj2의 normal을 메서드 호출 // -\u0026gt; normal의 setTimeout함수(내부함수)를 일반 호출 obj2.arrow(); // this === obj2 // ========== // const obj3 = { name: \u0026#34;yuchan\u0026#34;, outer: function () { console.log(this); // --- (1)obj3 const innerFunc = function () { console.log(this); // --- (2)window (3)obj4 }; innerFunc(); // --- (2) const obj4 = { name: \u0026#34;che\u0026#34;, innerMethod: innerFunc, }; obj4.innerMethod(); // --- (3) }, }; obj3.outer(); // --- (1) // (1)메서드 호출 (2)일반 호출 (3)메서드 호출 4. JSON # Methods Details JSON.stringify(obj) obj -\u0026gt; jsonStr, 직렬화(serialize) JSON.parse(jsonSrt) jsonStr -\u0026gt; obj, 역직렬화(deserialize) *JSON(JavaScript Object Notation)문자열은 쌍따옴표(\u0026quot;\u0026quot;)만 사용 가능\n5. Export \u0026amp; Import # // 이름 필수 X, 파일 하나당 하나만 가능 export default 데이터 // 이름 필수 O, 파일 하나당 여러개 가능 export 데이터 // export default import 임의_데이터명 from \u0026#34;경로\u0026#34;; // export import { 데이터명 } from \u0026#34;경로\u0026#34;; import { 데이터명 as 임의_데이터명 } from \u0026#34;경로\u0026#34;; import * as 임의_객체명 from \u0026#34;경로\u0026#34;; 6. Web Storage(웹 저장소) # vs Cookie\n클라이언트에 정보만 존재 \u0026lt;-\u0026gt; 요청 마다 서버에 함께 전송 (성능 저하 원인, 탈취 위험 높음) 용량 제한이 없음 \u0026lt;-\u0026gt; 있음 만료일이 없음 \u0026lt;-\u0026gt; 있음 Local Storage\n별도로 삭제할 때까지 영구 유지 도메인만 같으면 전역 공유 가능 Methods Details localStorage.setItem(\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;) 데이터 저장 localStorage.getItem(\u0026ldquo;key\u0026rdquo;) 데이터 불러오기 localStorage.removeItem(\u0026ldquo;key\u0026rdquo;) 데이터 삭제 Session Storage\n탭이나 브라우저가 종료되면 삭제 같은 도메인이라도 다른 탭이나 브라우저면 공유 불가능 7. Map \u0026amp; Set # Map\n객체와 유사한 자료구조\nsymbol이나 string이 아닌 key 사용 가능\nfor (const [key, value] of map)\nWeakMap\nWeakMap의 key 외에 참조가 없는 객체를 가비지 컬렉팅의 대상으로 만듦\n원시형 데이터를 key로 사용 못함\n반복작업 및 반복자 객체 반환 메서드를 사용 못함\nexample let user = { name: \u0026#34;adw\u0026#34;, age: 29 }; const userMap = new Map(); const userWeakMap = new WeakMap(); userMap.set(user, { married: false }); userWeakMap.set(user, { married: false }); user = null; console.log(user); // -\u0026gt; null console.log(userMap.get(user)); // -\u0026gt; undefined console.log(userMap.size); // -\u0026gt; 1 console.log(userWeakMap.get(user)); // -\u0026gt; undefined console.log(userWeakMap.size); // -\u0026gt; undefined Set\n배열과 유사한 자료구조 중복 요소를 가질 수 없음 const newArr = [\u0026hellip;new Set(arr)]로 배열의 중복 제거 가능 for (const item of set) Properties \u0026amp; Methods Type Details .size map, set 속성/요소의 갯수 .set(key, value) map 속성 추가, 문자열이 아닌 값도 키로 사용 가능 .get(key) map 속성 조회 .add(item) set 요소 추가 .has(key/item) map, set 해당 속성/요소 존재 여부 확인 .delete(key/item) map, set 해당 속성/요소 삭제 .clear() map, set 모든 속성/요소 삭제 .forEach() map, set 모든 속성/요소 삭제 .keys() map key를 삽입한 순서대로 가지고 있는 iterator(반복자 객체) 반환 .values() map value를 삽입한 순서대로 가지고 있는 iterator(반복자 객체) 반환 .entries() map [key, value]를 삽입한 순서대로 가지고 있는 iterator(반복자 객체) 반환 ","date":"1 January 0001","permalink":"/posts/summaries/javascript/","section":"Posts","summary":"JS Data # 1.","title":"Javascript"}]