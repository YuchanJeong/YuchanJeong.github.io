[{"content":"제 1장. Node.js란 # 1) 노드의 정의 # Chrome V8 엔진[1]으로 빌드된 자바스크립트 런타임 환경[2] libuv[3]를 내장 [1] Chrome V8 엔진: C++로 작성된 오픈소스 자바스크립트 엔진, 자바스크립트 코드를 기계어로 변환하여 실행시키는 JIT 컴파일러를 내장, 가비지 컬렉터를 내장하고 있어 메모리 관리에 대한 개발자의 부담을 덜어줌\n[2] 런타임 환경: 응용 프로그램이 운영체제(OS)의 시스템 리소스(e.g. RAM, 시스템 변수, 환경 변수)에 엑세스 할 수 있도록 해주는 실행 환경\n[3] libuv: 이벤트 기반의 비동기 I/O 라이브러리, 이벤트 루프 제공\n2) 노드의 특성 # 이벤트 기반 이벤트 리스너에 콜백 함수를 등록해서 이벤트(e.g. 클릭, 네트워크 요청, 타이머) 발생 시 미리 지정해둔 작업 수행 None-Blocking I/O 일부 코드(e.g. I/O 작업(파일 시스템 접근, 네트워크 요청), 압축, 암호화)는 백그라운드(다른 프로세스)에서 논-블로킹으로 실행 나머지 코드는 블로킹으로 실행 즉, I/O 작업이 많을 때 노드 활용성이 극대화 Single Tread 노드 프로세스는 멀티 스레드지만 직접 다룰 수 있는 스레드는 하나라서 싱글 스레드라고 표현 노드 14 버전부터 worker threads 모듈로 멀티 스레드 사용 가능 *프로세스 vs 스레드\n프로세스: 운영체제에서 할당하는 작업의 단위, 프로세스 간 리소스 공유 X 스레드: 프로세스 내에서 실행되는 작업의 단위, 부모 프로세스의 리소스 공유 O *멀티 프로세싱 vs 멀티 스레딩\n멀티 프로세싱: 여러 개의 프로세스 사용, I/O 요청이 많을 때 사용, 프로그래밍이 쉬움, 리소스를 적게 사용 멀티 스레딩: 하나의 프로세스 안에서 여러개의 스레드 사용, CPU 작업이 많을 때 사용, 프로그래밍이 어려움, 리소스를 많이 사용 3) 노드로 만든 서버 # 장점 단점 I/O 작업이 많은 서버에 적합 CPU 작업이 많은 서버에 부적합 리소스를 적게 사용 하나뿐인 스레드가 멈추지 않도록 관리 필요 프로그래밍이 쉬움 어중간한 성능 웹 서버 내장 JSON 형식과 호환이 쉬움 *CPU 작업을 위해 AWS Lamda, Google Cloud Functions 같은 별도 서비스 사용 권장\n제 2장. Javascript 기본 # 1) 콜 스택과 이벤트 루프 # 콜 스택\n가장 먼저 anonymous[1]가 쌓임 호출 순서대로 쌓이고, 역순으로 실행 이벤트 루프\n콜 스택에 쌓인 함수 중 논-블로킹으로 실행되는 함수들[2]을 백그라운드로 보냄 백그라운드에서 해당 함수가 완료되면 태스크 큐로 이동해서 대기 콜 스택이 비는 순간 이벤트 루프가 콜 스택으로 태스크를 이동 시켜서 실행 매크로 태스크[3] 큐(이벤트 큐, 콜백 큐)에서 가장 오래된 태스크를 실행 마이크로 태스크[4] 큐(잡 큐)의 모든 태스크를 오래된 순으로 실행 랜더링 매크로 태스크 큐 확인 및 대기 // example.js console.log(\u0026#34;script start\u0026#34;); setTimeout(function () { console.log(\u0026#34;setTimeout\u0026#34;); }, 0); Promise.resolve() .then(function () { console.log(\u0026#34;promise1\u0026#34;); }) .then(function () { console.log(\u0026#34;promise2\u0026#34;); }); console.log(\u0026#34;script end\u0026#34;); # console.log script start script end promise1 promise2 setTimeout *여기서 setTimeout이 첫 번째 매크로 태스크가 아니라 실행중인 스크립트(이벤트)가 첫 번째 매크로 태스크 (JS에서는 이벤트가 발생하지 않으면 코드가 실행되지 않기 때문)\n[1] anonymous: 모듈 스코프 외부에서 선언된 변수, 전역 변수로 취급\n[2] 논-블로킹으로 실행되는 함수들: 타이머 함수, 파일 시스템 접근(fs), 네트워크 요청, 압축(zlib), 암호화(crypto)\n[3] 매크로 태스크: requestAnimationFrame, I/O, UI rendering, setTimeout, setInterval, setImmediate\n[4] 마이크로 태스크: process.nextTick, Promises, queueMicrotask(f), MutationObserver\n*백그라운드와 태스크 큐는 자바스크립트가 아님\n*프로미스 내부는 동기, then/catch/finally는 비동기\n2) JS 기본 문법 # 내가 원래 정리해둔거 찾아오자\n3) 템플릿 문자열, 객체 리터럴 # fn`` tagged template literal\nconst food1 = \u0026lsquo;피자\u0026rsquo;; const food2 = \u0026lsquo;치킨\u0026rsquo;;\nconst foodMsg = (texts, \u0026hellip;values) =\u0026gt; { console.log(texts); console.log(values); }; foodMsg제가 어제 먹은 음식은 ${food1}그리고 ${food2}입니다.;\n// (3) [ \u0026lsquo;제가 어제 먹은 음식은 \u0026lsquo;, \u0026lsquo;그리고 \u0026lsquo;, \u0026lsquo;입니다.\u0026rsquo;, raw: Array(3) ] // (2) [ \u0026lsquo;피자\u0026rsquo;, \u0026lsquo;치킨\u0026rsquo; ]\n- [\u0026hellip;new Set(arr)]로 중복 요소를 제거한 새로운 Set 객체 생성 가능\n축약 가능 [변수 + 값] 동적 속성\n화살표 함수의 this는 부모의 this, function은 자신의 this를 가짐\nthis에 구조분해 할당 하면 문제가 생긴다!!! 하지만\n클래스가 프로토타입??? 뭔말이야 옛날에 이상한거를 클래스로 묶어서 잘 만들어 준거임\nresolve (성공) -\u0026gt; then으로 연결\nasync도 프로미스다\u0026hellip;\nmap은 생성자\nmap은 1대1 매칭\n일반 객체는 심볼이나 스트링만 됨\n참조값을 같은 참조를 해야 객체 키를\n반복적인거 강화\n좀 좋아보이네??\nset은 중복을 허용하지 않는 배열 생성자\n자료형이 다르면 됨\n배열에서 중복 제거하고 싶을 때 s2 = new Set([\u0026hellip;])\nArray.from(s2)\nWeakMap 좀 써봄 WeakSet 안써봄\n가비지 컬렉팅이 잘된다. 메모리에서 잘 날라간다.\n즉 객체를 키로 쓸 때나 뭐 이럴 때 객체는 널이 되어도 맵이 살아있으면 안지워짐 구지 필요는 없음\nconst user = {name: \u0026ldquo;adw\u0026rdquo;, age: 29}\nconst userWeakMap = new WeakMap() userWeakMap.set(user, {married: false})\n객체를 건드리지 않고, 가비지 컬렉팅을 부가적인 정보 추가\nuser = null 일 때 날라감\n위크셋을 쓸 일이 아예 없다!!!\nES2020에서 추가\n근데 AJAX가 뭐야?\n부록 # CLI # Command Details node -v node 버전 nvm -v nvm 버전 nvm install [version] 특정 버전 node 설치 nvm uninstall [version] 특정 버전 node 삭제 nvm ls node 목록 nvm use [version] 특정 버전 node 사용 sudo npm i -g npm npm 업데이트 강사 어록 # 생각의 비중이 높아야 한다. 그렇지 않다면 가치가 크지 않은 일을 하고 있을 가능성이 크다.\nhttps://blog.bitsrc.io/microtask-and-macrotask-a-hands-on-approach-5d77050e2168\n","date":"30 March 2023","permalink":"/posts/lectures/node.js-%EA%B5%90%EA%B3%BC%EC%84%9C/1/","section":"Posts","summary":"제 1장.","title":"[Node.js 교과서]"},{"content":"","date":"30 March 2023","permalink":"/categories/%5Clectures/","section":"Categories","summary":"","title":"\\lectures"},{"content":"","date":"30 March 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"30 March 2023","permalink":"/tags/node.js/","section":"Tags","summary":"","title":"node.js"},{"content":"","date":"30 March 2023","permalink":"/tags/node.js-%EA%B5%90%EA%B3%BC%EC%84%9C/","section":"Tags","summary":"","title":"Node.js 교과서"},{"content":"","date":"30 March 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"30 March 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" A blog from a developer who loves \u0026ldquo;Why?\u0026rdquo; :) Previous posts are in this repository. 😊 About me # Name Yuchan Jeong Work WithBecon(FE Developer) Languages Korean(Native), English(Intermediate) 👇 Follow me on # Mobile Number +82 10 8295 2674 E-mail yuchanjeong0923@gmail.com Blog https://yuchanjeong.github.io Github /yuchanjeong ","date":"30 March 2023","permalink":"/","section":"Yuchan's hello world!","summary":"A blog from a developer who loves \u0026ldquo;Why?","title":"Yuchan's hello world!"},{"content":"","date":"30 March 2023","permalink":"/tags/%EC%A1%B0%ED%98%84%EC%98%81zerocho/","section":"Tags","summary":"","title":"조현영(zerocho)"},{"content":"","date":"14 November 2022","permalink":"/categories/%5Cwork/","section":"Categories","summary":"","title":"\\work"},{"content":"","date":"14 November 2022","permalink":"/tags/i18n/","section":"Tags","summary":"","title":"i18n"},{"content":"","date":"14 November 2022","permalink":"/tags/react/","section":"Tags","summary":"","title":"react"},{"content":"배경 # 새로 진행하고 있는 B2B 프로젝트에 글로벌 진출 기회가 생겨서 다국어 처리를 할 필요가 생겼다.\n검색 결과 리액트에서 다국어 처리를 할 때는 보통 react-i18next나 react-intl을 사용하고 있었다. react-i18next는 번역에만 충실하나 후에 SSR이 필요할 때 next-i18next로 쉽게 전환할 수 있는 장점이 있었고, react-intl은 날짜, 시간, 숫자 등의 포멧팅을 지원하는 장점이 있었다.\n둘 다 이미 많은 사용자를 지니고 있어서 안정성은 확보되었다고 판단했고, 특별한 차이점도 없었기 때문에 npm trends와 npm compare에서 최근 결과가 더 좋은 react-i18next를 도입하기로 결정했다.\n도입 # 구글 스프레드 시트 연동\nhttps://console.cloud.google.com/apis/dashboard 사용자 인증 정보(Credentials) -\u0026gt; 사용자 인증 정보 만들기(CREATE CREDENTIALS) -\u0026gt; 서비스 계정(Service account) 서비스 계정(Service Accounts)에서 방금 생성한 계정 클릭 키(KEYS) 탭에서 JSON 파일로 새 키 만들기 세부정보(DETAILS) 탭에서 이메일 복사 후 구글 스프레드 시트에서 공유 설정 설치\nyarn add react-i18next i18next @types/react-i18next @types/i18next i18next-scanner google-spreadsheet 설정\nsrc/i18n/index.ts\rimport i18n from \u0026#34;i18next\u0026#34;; import { initReactI18next } from \u0026#34;react-i18next\u0026#34;; import { platform } from \u0026#34;modules/native\u0026#34;; import enUS from \u0026#34;./locales/en-US/translation.json\u0026#34;; import esES from \u0026#34;./locales/es-ES/translation.json\u0026#34;; import jaJP from \u0026#34;./locales/ja-JP/translation.json\u0026#34;; import koKR from \u0026#34;./locales/ko-KR/translation.json\u0026#34;; import viVN from \u0026#34;./locales/vi-VN/translation.json\u0026#34;; //*i18next: 언어 추가 시 작성 필요 const RESOURCES = { ko: { translation: koKR }, en: { translation: enUS }, ja: { translation: jaJP }, vi: { translation: viVN }, es: { translation: esES }, } as const; export type TLanguageCode = keyof typeof RESOURCES; export type TLanguageName = | \u0026#34;한국어\u0026#34; | \u0026#34;English\u0026#34; | \u0026#34;日本語\u0026#34; | \u0026#34;Tiếng Việt\u0026#34; | \u0026#34;español\u0026#34;; export type TLanguage = [TLanguageCode, TLanguageName]; export const LANGUAGES: TLanguage[] = [ [\u0026#34;ko\u0026#34;, \u0026#34;한국어\u0026#34;], [\u0026#34;en\u0026#34;, \u0026#34;English\u0026#34;], [\u0026#34;ja\u0026#34;, \u0026#34;日本語\u0026#34;], [\u0026#34;vi\u0026#34;, \u0026#34;Tiếng Việt\u0026#34;], [\u0026#34;es\u0026#34;, \u0026#34;español\u0026#34;], ]; const browserLang = window.navigator.language.split(\u0026#34;-\u0026#34;)[0]; export const CURRENT_LANGUAGE = \u0026#34;withbecon_language\u0026#34;; const userLanguage = platform !== \u0026#34;web\u0026#34; ? browserLang : localStorage.getItem(CURRENT_LANGUAGE) || browserLang; i18n.use(initReactI18next).init({ resources: RESOURCES, lng: userLanguage, fallbackLng: \u0026#34;en\u0026#34;, debug: false, defaultNS: \u0026#34;translation\u0026#34;, ns: \u0026#34;translation\u0026#34;, keySeparator: false, interpolation: { escapeValue: true, alwaysFormat: true, format(value, format, lng) { if (format === \u0026#34;uppercase\u0026#34;) return value.toUpperCase(); if (typeof value === \u0026#34;number\u0026#34;) return value.toLocaleString(lng); return value; }, }, react: { defaultTransParent: \u0026#34;div\u0026#34;, transEmptyNodeValue: \u0026#34;\u0026#34;, transSupportBasicHtmlNodes: true, transKeepBasicHtmlNodesFor: [ \u0026#34;br\u0026#34;, \u0026#34;strong\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;button\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;span\u0026#34;, \u0026#34;div\u0026#34;, \u0026#34;input\u0026#34;, ], transWrapTextNodes: \u0026#34;\u0026#34;, }, nsSeparator: \u0026#34;=\u0026gt;\u0026#34;, // default: \u0026#34;:\u0026#34; returnNull: false, returnEmptyString: false, }); export default i18n; export interface Ii18Next { // eslint-disable-next-line @typescript-eslint/ban-types t: (str: string, option?: Object) =\u0026gt; string; } export const i18nextScanKey = (key: string): string =\u0026gt; key; i18next-scanner.config.js\r/* eslint-disable import/order */ /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const typescript = require(\u0026#34;typescript\u0026#34;); const COMMON_EXTENSIONS = \u0026#34;/**/*.{js,jsx,ts,tsx,vue,html}\u0026#34;; module.exports = { input: [`./src/${COMMON_EXTENSIONS}`], options: { debug: true, removeUnusedKeys: true, defaultLng: \u0026#34;ko-KR\u0026#34;, //*i18next: 언어 추가 시 작성 필요 lngs: [\u0026#34;ko-KR\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;], func: { list: [\u0026#34;i18next.t\u0026#34;, \u0026#34;i18n.t\u0026#34;, \u0026#34;$i18n.t\u0026#34;, \u0026#34;$i18next.t\u0026#34;, \u0026#34;i18nextScanKey\u0026#34;], extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;], }, trans: { component: \u0026#34;Trans\u0026#34;, i18nKey: \u0026#34;i18nKey\u0026#34;, defaultsKey: \u0026#34;defaults\u0026#34;, extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;], fallbackKey: function (ns, value) { return value; }, acorn: { ecmaVersion: 10, sourceType: \u0026#34;module\u0026#34;, }, }, resource: { loadPath: path.join(__dirname, \u0026#34;/src/i18n/locales/{{lng}}/{{ns}}.json\u0026#34;), savePath: path.join(__dirname, \u0026#34;/src/i18n/locales/{{lng}}/{{ns}}.json\u0026#34;), }, defaultValue(lng, ns, key) { const keyAsDefaultValue = [\u0026#34;ko-KR\u0026#34;]; if (keyAsDefaultValue.includes(lng)) { const separator = \u0026#34;html\u0026#34;; const value = key.includes(separator) ? \u0026#34;\u0026#34; : key; return value; } return \u0026#34;\u0026#34;; }, keySeparator: false, nsSeparator: false, prefix: \u0026#34;{{\u0026#34;, suffix: \u0026#34;}}\u0026#34;, }, transform: (function typescriptTransform( options = { tsOptions: { target: \u0026#34;es2018\u0026#34;, }, extensions: [\u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;], } ) { return function transform(file, enc, done) { const { base, ext } = path.parse(file.path); if ( options.extensions.includes(ext) \u0026amp;\u0026amp; !base.endsWith(\u0026#34;.d.ts\u0026#34;) \u0026amp;\u0026amp; base.indexOf(\u0026#34;reportWebVitals.ts\u0026#34;) === -1 ) { const content = fs.readFileSync(file.path, enc); const { outputText } = typescript.transpileModule(content, { compilerOptions: options.tsOptions, fileName: path.basename(file.path), }); this.parser.parseTransFromString(outputText); this.parser.parseFuncFromString(outputText); } done(); }; })({ extensions: [\u0026#34;.tsx\u0026#34;, \u0026#34;.ts\u0026#34;], tsOptions: { target: \u0026#34;es5\u0026#34;, module: \u0026#34;esnext\u0026#34;, }, }), }; translate/.credentials/...\r.gitignore에 translate/.credentials 추가 서비스 계정에서 받은 JSON 키 파일을 translate/.credentials에 저장 translate/.credentials/index.js module.exports = { CREDS: \u0026#34;서비스 계정에서 받은 JSON 키 파일 이름\u0026#34;, // 구글 스프레드 시트 주소에 나와 있음 SHEET_DOC_ID: \u0026#34;...\u0026#34;, SHEET_ID: \u0026#34;...\u0026#34;, }; translate/index.js\r/* eslint-disable import/order */ /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const { GoogleSpreadsheet } = require(\u0026#34;google-spreadsheet\u0026#34;); const ENV = require(\u0026#34;./.credentials/index.js\u0026#34;); const creds = require(\u0026#34;./.credentials/\u0026#34; + ENV.CREDS); const i18nextConfig = require(\u0026#34;../i18next-scanner.config\u0026#34;); const spreadsheetDocId = ENV.SHEET_DOC_ID; const ns = \u0026#34;translation\u0026#34;; const lngs = i18nextConfig.options.lngs; const loadPath = i18nextConfig.options.resource.loadPath; const localesPath = loadPath.replace(\u0026#34;/{{lng}}/{{ns}}.json\u0026#34;, \u0026#34;\u0026#34;); const rePluralPostfix = new RegExp(/_plural|_[\\d]/g); const sheetId = ENV.SHEET_ID; const NOT_AVAILABLE_CELL = \u0026#34;_N/A\u0026#34;; //*i18next: 언어 추가 시 작성 필요 const columnKeyToHeader = { key: \u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;: \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;: \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;: \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;: \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;: \u0026#34;es-ES\u0026#34;, }; async function loadSpreadsheet() { // eslint-disable-next-line no-console console.info( \u0026#34;\\u001B[32m\u0026#34;, \u0026#34;=====================================================================================================================\\n\u0026#34;, \u0026#34;# i18next auto-sync using Spreadsheet\\n\\n\u0026#34;, \u0026#34; * Download translation resources from Spreadsheet and make /src/i18n/locales/{{lng}}/{{ns}}.json\\n\u0026#34;, \u0026#34; * Upload translation resources to Spreadsheet.\\n\\n\u0026#34;, `The Spreadsheet for translation is here (\\u001B[34mhttps://docs.google.com/spreadsheets/d/${spreadsheetDocId}/#gid=${sheetId}\\u001B[0m)\\n`, \u0026#34;=====================================================================================================================\u0026#34;, \u0026#34;\\u001B[0m\u0026#34; ); const doc = new GoogleSpreadsheet(spreadsheetDocId); await doc.useServiceAccountAuth(creds); await doc.loadInfo(); return doc; } function getPureKey(key = \u0026#34;\u0026#34;) { return key.replace(rePluralPostfix, \u0026#34;\u0026#34;); } module.exports = { localesPath, loadSpreadsheet, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, }; translate/upload.js\r/* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const { loadSpreadsheet, localesPath, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); //TODO-i18next: 언어 추가 시 작성 필요 const headerValues = [\u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;]; async function addNewSheet(doc, title, sheetId) { const sheet = await doc.addSheet({ sheetId, title, headerValues, }); return sheet; } async function updateTranslationsFromKeyMapToSheet(doc, keyMap) { const title = \u0026#34;시트 제목\u0026#34;; let sheet = doc.sheetsById[sheetId]; if (!sheet) { sheet = await addNewSheet(doc, title, sheetId); } const rows = await sheet.getRows(); const exsitKeys = {}; const addedRows = []; rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; if (keyMap[key]) { exsitKeys[key] = true; } }); for (const [key, translations] of Object.entries(keyMap)) { if (!exsitKeys[key]) { const row = { [columnKeyToHeader.key]: key, ...Object.keys(translations).reduce((result, lng) =\u0026gt; { const header = columnKeyToHeader[lng]; result[header] = translations[lng]; return result; }, {}), }; addedRows.push(row); } } await sheet.addRows(addedRows); } function toJson(keyMap) { const json = {}; Object.entries(keyMap).forEach(([, keysByPlural]) =\u0026gt; { for (const [keyWithPostfix, translations] of Object.entries(keysByPlural)) { json[keyWithPostfix] = { ...translations, }; } }); return json; } function gatherKeyMap(keyMap, lng, json) { for (const [keyWithPostfix, translated] of Object.entries(json)) { const key = getPureKey(keyWithPostfix); if (!keyMap[key]) { keyMap[key] = {}; } const keyMapWithLng = keyMap[key]; if (!keyMapWithLng[keyWithPostfix]) { keyMapWithLng[keyWithPostfix] = lngs.reduce((initObj, lng) =\u0026gt; { initObj[lng] = NOT_AVAILABLE_CELL; return initObj; }, {}); } keyMapWithLng[keyWithPostfix][lng] = translated; } } async function updateSheetFromJson() { const doc = await loadSpreadsheet(); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } const keyMap = {}; lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; // eslint-disable-next-line no-sync const json = fs.readFileSync(localeJsonFilePath, \u0026#34;utf8\u0026#34;); gatherKeyMap(keyMap, lng, JSON.parse(json)); }); updateTranslationsFromKeyMapToSheet(doc, toJson(keyMap)); }); } updateSheetFromJson(); /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const { loadSpreadsheet, localesPath, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); //*i18next: 언어 추가 시 작성 필요 const headerValues = [\u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;]; async function addNewSheet(doc, title, sheetId) { const sheet = await doc.addSheet({ sheetId, title, headerValues, }); return sheet; } async function updateTranslationsFromKeyMapToSheet(doc, keyMap) { const title = \u0026#34;B2B\u0026#34;; let sheet = doc.sheetsById[sheetId]; if (!sheet) { sheet = await addNewSheet(doc, title, sheetId); } const rows = await sheet.getRows(); const exsitKeys = {}; const addedRows = []; rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; if (keyMap[key]) { exsitKeys[key] = true; } }); for (const [key, translations] of Object.entries(keyMap)) { if (!exsitKeys[key]) { const row = { [columnKeyToHeader.key]: key, ...Object.keys(translations).reduce((result, lng) =\u0026gt; { const header = columnKeyToHeader[lng]; result[header] = translations[lng]; return result; }, {}), }; addedRows.push(row); } } await sheet.addRows(addedRows); } function toJson(keyMap) { const json = {}; Object.entries(keyMap).forEach(([, keysByPlural]) =\u0026gt; { for (const [keyWithPostfix, translations] of Object.entries(keysByPlural)) { json[keyWithPostfix] = { ...translations, }; } }); return json; } function gatherKeyMap(keyMap, lng, json) { for (const [keyWithPostfix, translated] of Object.entries(json)) { const key = getPureKey(keyWithPostfix); if (!keyMap[key]) { keyMap[key] = {}; } const keyMapWithLng = keyMap[key]; if (!keyMapWithLng[keyWithPostfix]) { keyMapWithLng[keyWithPostfix] = lngs.reduce((initObj, lng) =\u0026gt; { initObj[lng] = NOT_AVAILABLE_CELL; return initObj; }, {}); } keyMapWithLng[keyWithPostfix][lng] = translated; } } async function updateSheetFromJson() { const doc = await loadSpreadsheet(); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } const keyMap = {}; lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; // eslint-disable-next-line no-sync const json = fs.readFileSync(localeJsonFilePath, \u0026#34;utf8\u0026#34;); gatherKeyMap(keyMap, lng, JSON.parse(json)); }); updateTranslationsFromKeyMapToSheet(doc, toJson(keyMap)); }); } updateSheetFromJson(); translate/download.js\r/* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const mkdirp = require(\u0026#34;mkdirp\u0026#34;); const { loadSpreadsheet, localesPath, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); /** * fetch translations from google spread sheet and transform to json * @param {GoogleSpreadsheet} doc GoogleSpreadsheet document * @returns [object] translation map * { * \u0026#34;ko-KR\u0026#34;: { * \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; * }, * \u0026#34;en-US\u0026#34;: { * \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; * }, * } */ async function fetchTranslationsFromSheetToJson(doc) { const sheet = doc.sheetsById[sheetId]; if (!sheet) { return {}; } const lngsMap = {}; const rows = await sheet.getRows(); rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; lngs.forEach((lng) =\u0026gt; { const translation = row[columnKeyToHeader[lng]]; if (translation === NOT_AVAILABLE_CELL) { return; } if (!lngsMap[lng]) { lngsMap[lng] = {}; } lngsMap[lng][key] = translation || \u0026#34;\u0026#34;; }); }); return lngsMap; } function checkAndMakeLocaleDir(dirPath, subDirs) { return new Promise((resolve) =\u0026gt; { subDirs.forEach((subDir, index) =\u0026gt; { mkdirp(`${dirPath}/${subDir}`, (err) =\u0026gt; { if (err) { throw err; } if (index === subDirs.length - 1) { resolve(); } }); }); }); } async function updateJsonFromSheet() { await checkAndMakeLocaleDir(localesPath, lngs); const doc = await loadSpreadsheet(); const lngsMap = await fetchTranslationsFromSheetToJson(doc); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; const jsonString = JSON.stringify(lngsMap[lng], null, 2); fs.writeFile(localeJsonFilePath, jsonString, \u0026#34;utf8\u0026#34;, (err) =\u0026gt; { if (err) { throw err; } }); }); }); } updateJsonFromSheet(); src/index.tsx\rimport \u0026#34;i18n\u0026#34;; ... package.json\r\u0026#34;scripts\u0026#34;: { ..., \u0026#34;scan:i18n\u0026#34;: \u0026#34;i18next-scanner --config i18next-scanner.config.js\u0026#34;, \u0026#34;upload:i18n\u0026#34;: \u0026#34;yarn run scan:i18n \u0026amp;\u0026amp; node translate/upload.js\u0026#34;, \u0026#34;download:i18n\u0026#34;: \u0026#34;node translate/download.js\u0026#34; }, 사용법 # # i18next.t()로 감싸져 있는 키를 스캔 후 업로드 yarn upload:i18n # 구글 스프레드 시트에서 번역을 받아옴 yarn download:i18n import { Trans, useTranslation } from \u0026#34;react-i18next\u0026#34;; import type { Ii18Next } from \u0026#39;i18n\u0026#39;; export default function Example() { const i18next = useTranslation(); // scan을 위한 자체 컨벤션으로 \u0026#34;i18next\u0026#34; 사용 const getTabList = (i18next: Ii18Next) =\u0026gt; [ { id: 1, label: i18next.t(\u0026#34;예시 1\u0026#34;) }, { id: 2, label: i18next.t(\u0026#34;예시 2\u0026#34;) }, { id: 3, label: i18next.t(\u0026#34;예시 3\u0026#34;) }, ]; const tabList = getTabList(i18next); return ( \u0026lt;div\u0026gt; // 1) 일반 사용 {i18next.t(\u0026#34;이메일\u0026#34;)} // 2) 변수 사용 {i18next.t( `이메일은 \u0026#34;{{email}}\u0026#34;이고 , 비밀번호는 \u0026#34;{{password}}\u0026#34;이다.`, { email: \u0026#34;example@gmail.com\u0026#34;, password: \u0026#34;1234\u0026#34; }, )} // 3) 단수・복수 사용; 변수명으로 count를 사용 해야함 {i18next.t(`같은 명의로 만들어진 아이디는 {{count}}개입니다.`, { count: 3 })} // 4) html 태그 사용; i18nKey에 \u0026#34;html\u0026#34;을 포함 해야함 (scan을 위한 자체 컨벤션) \u0026lt;Trans i18nKey=\u0026#34;예시 html\u0026#34;\u0026gt; {{ name: \u0026#34;정유찬\u0026#34; }}님은 i18next를 \u0026lt;br /\u0026gt; 사용할 수 있습니다. \u0026lt;/Trans\u0026gt; // 5) return 외부에서 사용 {tabList.map((tab) =\u0026gt; ( \u0026lt;div\u0026gt; {tab.label} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt;; ) } *조건부 서식을 활용해서 작업이 필요한 부분의 가시성을 높혔다.\nPs. 언어 변경 Select\rimport { useEffect } from \u0026#34;react\u0026#34;; import { useSelect } from \u0026#34;hooks/useSelect\u0026#34;; import i18n, { CURRENT_LANGUAGE, LANGUAGE_LIST } from \u0026#34;i18n\u0026#34;; export default function LanguageSelector() { const languageSelect = useSelect( LANGUAGE_LIST.findIndex((language) =\u0026gt; language[0] === i18n.language) !== -1 ? i18n.language : \u0026#34;ko\u0026#34; ); useEffect(() =\u0026gt; { i18n.changeLanguage(languageSelect.value); localStorage.setItem(CURRENT_LANGUAGE, languageSelect.value); }, [languageSelect.value]); return ( \u0026lt;select {...languageSelect.attribute}\u0026gt; {LANGUAGE_LIST.map((language) =\u0026gt; ( \u0026lt;option key={language[0]} value={language[0]}\u0026gt; {language[1]} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ); } import { useState, ChangeEvent, SelectHTMLAttributes, DetailedHTMLProps, } from \u0026#34;react\u0026#34;; type TUseSelectProps = { initialValue?: string; selectAttributes?: DetailedHTMLProps\u0026lt; SelectHTMLAttributes\u0026lt;HTMLSelectElement\u0026gt;, HTMLSelectElement \u0026gt;; }; export const useSelect = ({ initialValue = \u0026#34;\u0026#34;, selectAttributes = {}, }: TUseSelectProps = {}) =\u0026gt; { const [value, setValue] = useState(initialValue); const onChange = (event: ChangeEvent\u0026lt;HTMLSelectElement\u0026gt;) =\u0026gt; { const newValue = event.target.value; if (newValue !== value) setValue(newValue); }; return { attribute: { value, onChange, ...selectAttributes }, value, setValue, }; }; Reference.\nhttps://npmtrends.com/react-i18next-vs-react-intl https://npmcompare.com/compare/i18n-react,react-i18next,react-intl,react-intl-redux [React] 국제화(internationalization, i18n) 라이브러리 비교 https://www.i18next.com/ 기존 프로젝트에 다국어 처리를 적용해보자(react-i18next) ","date":"14 November 2022","permalink":"/posts/work/5/","section":"Posts","summary":"배경 # 새로 진행하고 있는 B2B 프로젝트에 글로벌 진출 기회가 생겨서 다국어 처리를 할 필요가 생겼다.","title":"다국어 처리 (react-i18next)"},{"content":"Axios Instance # base url 설정, 헤더에 액세스 토큰 포함, 액세스 토큰 만료 시 재발급 그리고 리프레시 토큰 만료 시 로그아웃을 axiosInstance를 통해 공통 설정으로 처리했다.\nyarn add axios axiosInstance.ts\rimport axios from \u0026#34;axios\u0026#34;; import { getAccessToken, logout, TOKEN_INFO } from \u0026#34;modules/account/apis\u0026#34;; import type { AxiosRequestConfig, AxiosResponse, AxiosError } from \u0026#34;axios\u0026#34;; // ===== Setting ===== // //# Set URL const config: AxiosRequestConfig = { baseURL: `https://${process.env.REACT_APP_BRANCH}.becon-api.com`, }; export const axiosInstance = axios.create(config); //# Set Authorization export const setAxiosHeader = (accessToken: string) =\u0026gt; { axiosInstance.defaults.headers.common.Authorization = `Bearer ${accessToken}`; }; // ===== Preprocessing ===== // //# Fulfilled Response (200번대 응답) const onFulfilled = (res: AxiosResponse): AxiosResponse =\u0026gt; { return res; }; //# Rejected Response (200번대 외 응답) const onRejected = async (err: AxiosError): Promise\u0026lt;AxiosResponse\u0026gt; =\u0026gt; { const { config, response } = err; if (!config) return Promise.reject(err); // [edge-case] 요청의 설정이 없을 시 //## Access Token 만료 시 if (response?.status === 401) { const tokenInfoStr = localStorage.getItem(TOKEN_INFO); if (!tokenInfoStr) return Promise.reject(err); // [edge-case] Local Storage에 정보가 없을 시 const tokenInfo: { accessToken: string; refreshToken: string; } = JSON.parse(tokenInfoStr); try { // 0. Refresh Token으로 새로운 Access Token 획득 const newAccessToken = await getAccessToken({ refreshToken: tokenInfo.refreshToken, }); // 1. 권한 부여 헤더의 Access Token 교체 setAxiosHeader(newAccessToken); // 2. Local Storage의 Access Token 교체 localStorage.setItem( TOKEN_INFO, JSON.stringify({ ...tokenInfo, accessToken: newAccessToken, }) ); // 3. 현재 요청의 Access Token 교체 if (!config.headers) config.headers = {}; // [edge-case] 요청에 헤더가 없을 시 config.headers.Authorization = `Bearer ${newAccessToken}`; return axiosInstance(config); } catch (err: unknown) { // [edge-case] Refresh Token 만료 시 logout({ isExpired: true }); return Promise.reject(err); } } return Promise.reject(err); }; axiosInstance.interceptors.response.use(onFulfilled, onRejected); account/apis/index.ts\rexport const ID = \u0026#34;withbecon_id\u0026#34;; export const TOKEN_INFO = \u0026#34;withbecon_token_info\u0026#34;; export const EXPIRED = \u0026#34;withbecon_expired\u0026#34;; export const INVALID = \u0026#34;withbecon_invalid\u0026#34;; /** 이메일 로그인 */ export const emailLogin = async ({ email, password, }: { email: string; password: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ result: TLogin }\u0026gt;(\u0026#34;/account/auth\u0026#34;, { email, password, }); const tokenInfo = { accessToken: res.data.result.access_token, refreshToken: res.data.result.refresh_token, }; setAxiosHeader(tokenInfo.accessToken); localStorage.setItem(ID, email); localStorage.setItem(TOKEN_INFO, JSON.stringify(tokenInfo)); return res.data.result; }; /** 휴대폰번호 로그인 */ export const phoneNumberLogin = async ({ phone_number, password, }: { phone_number: string; password: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ result: TLogin }\u0026gt;( \u0026#34;/account/auth/phone\u0026#34;, { phone_number, password, } ); const tokenInfo = { accessToken: res.data.result.access_token, refreshToken: res.data.result.refresh_token, }; setAxiosHeader(tokenInfo.accessToken); localStorage.setItem(ID, phone_number); localStorage.setItem(TOKEN_INFO, JSON.stringify(tokenInfo)); return res.data.result; }; /** 로그아웃 (query X) */ export const logout = ({ isExpired, isInvalid, }: { isExpired?: boolean; isInvalid?: boolean; } = {}) =\u0026gt; { if (isExpired) localStorage.setItem(EXPIRED, EXPIRED); if (isInvalid) localStorage.setItem(INVALID, INVALID); localStorage.removeItem(TOKEN_INFO); window.location.replace(window.location.origin); }; /** 엑세스 토큰 조회 (query X) */ export const getAccessToken = async ({ refreshToken, }: { refreshToken: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ access_token: string }\u0026gt;( \u0026#34;account/auth/refresh\u0026#34;, { refresh_token: refreshToken } ); return res.data.access_token; }; /** 어카운트 정보 조회 */ export const getAccount = async () =\u0026gt; { const res = await axiosInstance.get\u0026lt;{ account: TAccount }\u0026gt;(\u0026#34;my/account\u0026#34;); return res.data.account; }; React Query # yarn add @tanstack/react-query @tanstack/react-query-devtools index.tsx\rconst root = ReactDOM.createRoot( document.getElementById(\u0026#34;root\u0026#34;) as HTMLElement ); root.render( \u0026lt;QueryClientProvider client={queryClient}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;ReactQueryDevtools /\u0026gt; \u0026lt;/QueryClientProvider\u0026gt; ); queryClient.tsx\rconst generateQueryClient = (): QueryClient =\u0026gt; { return new QueryClient({ defaultOptions: { queries: { suspense: true, refetchOnWindowFocus: false, retry: 1, onError: queryErrorHandler, }, mutations: { onError: queryErrorHandler, }, }, }); }; export const queryClient = generateQueryClient(); queryErrorHandler.ts\rconst queryErrorHandler = (err: unknown): void =\u0026gt; { alert(`withbecon server error -\u0026gt; ${err}`); window.location.replace(window.location.origin); }; export default queryErrorHandler; ","date":"13 November 2022","permalink":"/posts/work/4/","section":"Posts","summary":"Axios Instance # base url 설정, 헤더에 액세스 토큰 포함, 액세스 토큰 만료 시 재발급 그리고 리프레시 토큰 만료 시 로그아웃을 axiosInstance를 통해 공통 설정으로 처리했다.","title":"[프로젝트 초기 설정] Axios Instance \u0026 React Query"},{"content":"","date":"13 November 2022","permalink":"/tags/axios/","section":"Tags","summary":"","title":"axios"},{"content":"","date":"13 November 2022","permalink":"/tags/react-query/","section":"Tags","summary":"","title":"react-query"},{"content":"코드 스플리팅 # 리액트에서 활용 가능한 여러 방식의 코드 스플리팅이 있지만 우선 회사의 다른 프로젝트에서 사용하고 있는 loadable component를 활용한 페이지(라우팅) 기반의 코드 스플리팅만 적용 했다.\nyarn add @loadable/component @types/loadable__component App.tsx\nimport loadable from \u0026#34;@loadable/component\u0026#34;; ... const ExamplePage = loadable(() =\u0026gt; import(\u0026#34;pages/ExamplePage\u0026#34;)) ... function App() { return ( \u0026lt;Router\u0026gt; \u0026lt;Routes\u0026gt; \u0026lt;Route path=\u0026#34;/example\u0026#34; element={\u0026lt;ExamplePage /\u0026gt;} /\u0026gt; ... \u0026lt;Route path=\u0026#34;*\u0026#34; element={\u0026lt;NotFound /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/Router\u0026gt; ) } SASS(SCSS) # /* ===== 1) reset ===== */ @import \u0026#34;base/reset\u0026#34;; /* ... */ * { margin: 0; padding: 0; font: inherit; color: inherit; } *, :after, :before { box-sizing: border-box; flex-shrink: 0; } :root { line-height: 1.5; -moz-tab-size: 4; tab-size: 4; cursor: default; // 모바일에서 꾹 클릭 시 색상 변경 방지 -webkit-tap-highlight-color: transparent; // 내용 선택 방지 -webkit-touch-callout: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; // 모바일에서 폰트 크기 조정 방지 -webkit-text-size-adjust: none; -moz-text-size-adjust: none; text-size-adjust: none; // 글이 상자 벗어나는 거 방지 overflow-wrap: break-word; // 폰트 랜더링 부드럽게 만들기 -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; } html, body { height: 100%; // 최상위 부모 요소 기본 크기 설정 font-size: 62.5%; // 1rem === 10px font-weight: 400; font-style: normal; } img { -webkit-user-drag: none; } img, picture, video, canvas, svg { // 위치값을 가지고 상자 벗어나는거 방지 display: block; max-width: 100%; } // Chrome 자동 완성 배경색 지우기 input:-webkit-autofill { box-shadow: 0 0 0 30px transparent inset; } input:-webkit-autofill, input:-webkit-autofill:hover, input:-webkit-autofill:focus, input:-webkit-autofill:active { transition: background-color 5000s ease-in-out 0s; } // 선택 및 입력 스타일 초기화 button, input, select, progress { appearance: none; -webkit-appearance: none; background-color: transparent; border: 0; \u0026amp;:focus, \u0026amp;:active { outline: none; box-shadow: none; } } meter { border: 0; } textarea { \u0026amp;:focus, \u0026amp;:active { box-shadow: none; outline: none; } } // 입력 대상 커서 텍스트로 변경 input, textarea { cursor: text; } // 선택 대상 커서 포인터로 변경 a, button, select, input[type=\u0026#34;checkbox\u0026#34;], input[type=\u0026#34;radio\u0026#34;], input[type=\u0026#34;range\u0026#34;], label { cursor: pointer; } // 링크 스타일 초기화 a { text-decoration: none; } // 표 스타일 초기와 table { border-collapse: collapse; border-spacing: 0; } // 목록 스타일 초기화 ul, ol { padding-left: 0; list-style: none; } *_(underscore)를 scss 파일 이름 앞에 붙일 경우 부분 파일로 취급해서 작업 시점에는 모듈화되어 있지만 실제로 사용되는 시점에는 main.scss 파일 하나에 작성된다.\nReference.\n코드 스플리팅 https://velog.io/@velopert/react-code-splitting SCSS https://www.joshwcomeau.com/css/custom-css-reset/ 2022 CSS Reset 다시 써보기! [css-real] 드래그(drag) 막기 ","date":"12 November 2022","permalink":"/posts/work/3/","section":"Posts","summary":"코드 스플리팅 # 리액트에서 활용 가능한 여러 방식의 코드 스플리팅이 있지만 우선 회사의 다른 프로젝트에서 사용하고 있는 loadable component를 활용한 페이지(라우팅) 기반의 코드 스플리팅만 적용 했다.","title":"[프로젝트 초기 설정] 코드 스플리팅 \u0026 SASS"},{"content":"","date":"12 November 2022","permalink":"/tags/sass/","section":"Tags","summary":"","title":"sass"},{"content":"배경 # 다른 팀원들이 기존 업무로 바빴기 때문에 신규 B2B 프로젝트에 나만 우선 투입되었다. (\u0026ldquo;곧 신규 프로젝트를 시작할 것이고 이 신규 프로젝트를 주도적으로 이끌어 나갈 수 있을 것이다.\u0026ldquo;라고 면접 때 들었고 이것이 내가 이 회사를 선택한 주된 이유 중 하나이기도 해서 매우 기대가 됨) 효율적인 협업을 위해 eslint(linter)와 prettier(formatter)로 코드 스타일을 맞추고 이를 효율적으로 확실히 지키기 위해 lint-staged(변경된 파일만 lint 검사)와 husky(git hook 공유)를 사용했다.\n1) 프로젝트 시작 # yarn create-react-app [project name] --template typescript 2) ESLint와 Prettier 적용 # yarn add eslint prettier eslint-config-prettier eslint-plugin-import @typescript-eslint/parser eslint-import-resolver-typescript -D npx eslint --init ✔ How would you like to use ESLint? · problems ✔ What type of modules does your project use? · esm ✔ Which framework does your project use? · react ✔ Does your project use TypeScript? · No / Yes ✔ Where does your code run? · browser ✔ What format do you want your config file to be in? · JSON The config that you\u0026#39;ve selected requires the following dependencies: eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest ✔ Would you like to install them now? · No / Yes ✔ Which package manager do you want to use? · yarn .eslintrc.json\r{ \u0026#34;env\u0026#34;: { \u0026#34;browser\u0026#34;: true, \u0026#34;es2021\u0026#34;: true }, \u0026#34;extends\u0026#34;: [ \u0026#34;eslint:recommended\u0026#34;, \u0026#34;plugin:react/recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;plugin:import/typescript\u0026#34;, \u0026#34;plugin:import/recommended\u0026#34;, \u0026#34;prettier\u0026#34; ], \u0026#34;overrides\u0026#34;: [], \u0026#34;parser\u0026#34;: \u0026#34;@typescript-eslint/parser\u0026#34;, \u0026#34;parserOptions\u0026#34;: { \u0026#34;ecmaVersion\u0026#34;: \u0026#34;latest\u0026#34;, \u0026#34;sourceType\u0026#34;: \u0026#34;module\u0026#34; }, \u0026#34;plugins\u0026#34;: [\u0026#34;react\u0026#34;, \u0026#34;react-hooks\u0026#34;, \u0026#34;@typescript-eslint\u0026#34;], \u0026#34;settings\u0026#34;: { \u0026#34;import/resolver\u0026#34;: { \u0026#34;node\u0026#34;: {}, \u0026#34;typescript\u0026#34;: { \u0026#34;directory\u0026#34;: \u0026#34;./src\u0026#34; } }, \u0026#34;import/parsers\u0026#34;: { \u0026#34;@typescript-eslint/parser\u0026#34;: [\u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;] } }, \u0026#34;rules\u0026#34;: { \u0026#34;react/react-in-jsx-scope\u0026#34;: 0, \u0026#34;import/order\u0026#34;: [ \u0026#34;error\u0026#34;, { \u0026#34;groups\u0026#34;: [ \u0026#34;builtin\u0026#34;, \u0026#34;external\u0026#34;, \u0026#34;internal\u0026#34;, [\u0026#34;parent\u0026#34;, \u0026#34;sibling\u0026#34;, \u0026#34;index\u0026#34;], \u0026#34;type\u0026#34;, \u0026#34;unknown\u0026#34; ], \u0026#34;pathGroups\u0026#34;: [ { \u0026#34;pattern\u0026#34;: \u0026#34;./*.scss\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;type\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;after\u0026#34; } ], \u0026#34;alphabetize\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;caseInsensitive\u0026#34;: true }, \u0026#34;newlines-between\u0026#34;: \u0026#34;always\u0026#34; } ], \u0026#34;react-hooks/rules-of-hooks\u0026#34;: 2, \u0026#34;react-hooks/exhaustive-deps\u0026#34;: 2, \u0026#34;import/export\u0026#34;: 0, \u0026#34;import/no-unresolved\u0026#34;: 0, \u0026#34;eslint-disable-next-line\u0026#34;: 0, \u0026#34;import/no-named-as-default-member\u0026#34;: 0 } } .prettierrc.json\r{ \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;css\u0026#34;, \u0026#34;insertPragma\u0026#34;: false, \u0026#34;jsxBracketSameLine\u0026#34;: false, \u0026#34;jsxSingleQuote\u0026#34;: false, \u0026#34;printWidth\u0026#34;: 80, \u0026#34;proseWrap\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;quoteProps\u0026#34;: \u0026#34;as-needed\u0026#34;, \u0026#34;requirePragma\u0026#34;: false, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: false, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;useTabs\u0026#34;: false, \u0026#34;vueIndentScriptAndStyle\u0026#34;: false } 3) Lint-Staged와 Husky 적용 # npx mrm lint-staged package.json\r{ ..., \u0026#34;lint-staged\u0026#34;: { \u0026#34;*.{js,jsx,ts,tsx}\u0026#34;: [ \u0026#34;prettier --write\u0026#34;, \u0026#34;eslint --fix\u0026#34; ] } } npx husky-init .husky/pre-commit\r#!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; yarn lint-staged ❗️node_modules를 재설치 할 경우 다시 해줘야 함\n","date":"11 November 2022","permalink":"/posts/work/2/","section":"Posts","summary":"배경 # 다른 팀원들이 기존 업무로 바빴기 때문에 신규 B2B 프로젝트에 나만 우선 투입되었다.","title":"[프로젝트 초기 설정] 협업 준비"},{"content":"","date":"11 November 2022","permalink":"/tags/convention/","section":"Tags","summary":"","title":"convention"},{"content":"","date":"11 November 2022","permalink":"/tags/eslint/","section":"Tags","summary":"","title":"eslint"},{"content":"","date":"11 November 2022","permalink":"/tags/husky/","section":"Tags","summary":"","title":"husky"},{"content":"","date":"11 November 2022","permalink":"/tags/lint-staged/","section":"Tags","summary":"","title":"lint-staged"},{"content":"","date":"11 November 2022","permalink":"/tags/prettier/","section":"Tags","summary":"","title":"prettier"},{"content":"","date":"11 November 2022","permalink":"/tags/typescript/","section":"Tags","summary":"","title":"typescript"},{"content":"배경 # 제품 상세페이지의 제품 이미지 바로 아래에 해당 제품의 평균 별점이 보이면 좋겠다는 의견이 나와서 이를 반영하기로 했다. 리뷰에 이미 평균 별점을 보여주는 기능이 적용되어 있었지만 별이 정수 단위로만 채워지고 있어서(예시. 4.3점이면 네 개, 4.5점이면 다섯 개) 소수점까지 정확히 반영되는 별점을 만들고 싶었다.\n시행착오 # 처음에는 별 5개가 나란히 있는 이미지를 받은 다음 아래에는 비어있는 별을, 위에는 채워져 있는 별을 겹쳐서 배치한 다음 채워져 있는 별의 부모 요소 넓이를 백분율에 따라 줄이고 overflow: hidden; 스타일을 적용하는 것으로 쉽게 구현했었다. 하지만 별 사이의 간격까지 백분율에 반영해 버리는 문제점을 지니고 있었다.\n구현 # 문제점을 해결하기 위해서 별 하나하나를 정수로 구분하고 별 내부를 소수점으로 구분하는 방법을 사용했다. 그리고 소수점 단위의 스타일 적용을 sass에서 구현하기 위해서 https://www.sassmeister.com/ 사이트를 참조해가며 반복문을 작성했다. (styled-component의 props가 잠시 그리워지는 시점이었다.) 마지막으로 별의 일부만 채우는 기능을 구현하기 위해 \u0026lt;svg/\u0026gt;에 margin-left: ...;를 마이너스 단위로 줘서 이동시킨 다음 내부의 \u0026lt;path/\u0026gt;를 transform: translateX(...);로 다시 이동시키는 방법을 사용했다.\n별점 리뷰 컴포넌트\rimport { StarSvg } from \u0026#34;src/assets/index\u0026#34;; import styles from \u0026#34;./StarReview.module.scss\u0026#34;; interface IStarsProps { score: number | undefined; size: string; emptyColor: string; filledColor: string; } /** * 5점 만점의 별점 리뷰 컴포넌트 `★★★★☆` * @score 별점(1~5점) e.g. `4.3` * @size 크기 e.g. `4vw` * @emptyColor 비었을 때 색상 e.g. `\u0026#34;#EEEDEF\u0026#34;` * @filledColor 찼을 때 색상 e.g. `\u0026#34;#6435C7\u0026#34;` */ export default function StarReview({ score, size, emptyColor, filledColor, }: IStarsProps) { const arr = new Array(5).fill(0); const _score = score || 0; const integer = Math.floor(_score); const decimal = Number((Number(_score.toFixed(1)) - integer).toFixed(1)) * 10; return ( \u0026lt;div className={styles.container}\u0026gt; \u0026lt;div className={styles.stars}\u0026gt; {arr.map((_, i) =\u0026gt; ( \u0026lt;StarSvg width={size} height={size} fill={emptyColor} key={i} /\u0026gt; ))} \u0026lt;/div\u0026gt; {!_score || _score \u0026lt; 1 || _score \u0026gt; 5 ? null : ( \u0026lt;div className={styles.stars} data-type=\u0026#34;filled\u0026#34;\u0026gt; {arr.map((_, i) =\u0026gt; ( \u0026lt;div key={i} data-decimal={decimal} data-index={i === integer ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;} data-empty={i \u0026gt; integer ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;} \u0026gt; \u0026lt;StarSvg width={size} height={size} fill={filledColor} /\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ); } 별점 리뷰 스타일\r.container { position: relative; .stars { display: flex; gap: 4px; \u0026amp;[data-type=\u0026#34;filled\u0026#34;] { top: 0; position: absolute; @for $i from 0 through 9 { \u0026gt; div[data-decimal=\u0026#34;#{$i}\u0026#34;][data-index=\u0026#34;true\u0026#34;] \u0026gt; svg { margin-left: -(100% - percentage($i * 0.1)); \u0026gt; path { transform: translateX(100% - percentage($i * 0.1)); } } } \u0026gt; div[data-empty=\u0026#34;true\u0026#34;] \u0026gt; svg { display: none; } } } } 별 이미지 (svg)\r\u0026lt;svg width=\u0026#34;current\u0026#34; height=\u0026#34;current\u0026#34; viewBox=\u0026#34;0 0 16 16\u0026#34; fill=\u0026#34;none\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; \u0026gt; \u0026lt;path d=\u0026#34;M7.71663 0.815216C7.81002 0.546548 8.18998 0.546548 8.28337 0.815216L9.81237 5.21396C9.85357 5.33248 9.96418 5.41284 10.0896 5.4154L14.7456 5.51028C15.0299 5.51608 15.1474 5.87744 14.9207 6.04928L11.2097 8.86273C11.1097 8.93854 11.0675 9.06857 11.1038 9.18867L12.4524 13.6461C12.5347 13.9183 12.2273 14.1416 11.9939 13.9792L8.17135 11.3192C8.06836 11.2476 7.93164 11.2476 7.82865 11.3192L4.00614 13.9792C3.77267 14.1416 3.46527 13.9183 3.54764 13.6461L4.89617 9.18867C4.9325 9.06857 4.89025 8.93854 4.79027 8.86273L1.0793 6.04928C0.852639 5.87744 0.970053 5.51608 1.25443 5.51028L5.91037 5.4154C6.03582 5.41284 6.14643 5.33248 6.18763 5.21396L7.71663 0.815216Z\u0026#34; fill=\u0026#34;current\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; export { ReactComponent as StarSvg } from \u0026#34;./star.svg\u0026#34;; *CRA 시에만 ReactComponent 사용 가능\n주의사항 # 해당 코드를 다른 프로젝트에 적용할 때 제대로 적용되지 않는 문제가 발생했다. 문제를 해결하기 위해 개발자 모드에서 스타일을 하나하나 꺼보면서 원인을 파악했다. 원인은 문제가 발생하는 프로젝트에 전역으로 text-align: center; 스타일이 먹혀있는 것이었다. 이 경험 덕에 전역으로 스타일을 먹이는 것은 위험하다는 것과 svg도 text-align이 먹힌다는 것을 배웠다.\n참조 # 출근 첫날 회사의 코드를 살펴보는 과정에서 이 코드를 보고는 \u0026ldquo;이런 식으로 sass에서 반복문을 활용하는구나\u0026quot;를 알게 되었고 메모장에 메모해 뒀었다. (취업 전에는 styled-component와 tailwind-CSS를 주로 사용해서 sass에 대한 이해도가 상대적으로 부족했다.) 그리고 별점의 소수점을 어떻게 sass에서 반영할 수 있을까를 고민하는 과정에서 이 코드가 떠올랐고 이를 참조해서 문제를 쉽게 해결할 수 있었다.\n$spacesPx: (2, 4, 6, 8, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100); @each $space in $spacesPx { .mt#{$space} { margin-top: #{$space}px; } .mr#{$space} { margin-right: #{$space}px; } .mb#{$space} { margin-bottom: #{$space}px; } .ml#{$space} { margin-left: #{$space}px; } } ","date":"5 November 2022","permalink":"/posts/work/1/","section":"Posts","summary":"배경 # 제품 상세페이지의 제품 이미지 바로 아래에 해당 제품의 평균 별점이 보이면 좋겠다는 의견이 나와서 이를 반영하기로 했다.","title":"평균 별점 (소수점 반영)"},{"content":"","date":"31 October 2022","permalink":"/categories/%5Cetc/","section":"Categories","summary":"","title":"\\etc"},{"content":"","date":"31 October 2022","permalink":"/tags/error/","section":"Tags","summary":"","title":"error"},{"content":"","date":"31 October 2022","permalink":"/tags/git/","section":"Tags","summary":"","title":"git"},{"content":"배경 # 취업을 하게 되면서 컴퓨터 두 대(개인 컴퓨터와 회사 컴퓨터)를 이용해 블로깅을 하게 되었고, 이 과정에서 서브 모듈 관련 문제를 만났다.\n문제 # blog 저장소에는 블로그 설정, 테마 등의 모든 요소가 저장되고 yuchanjeong.github.io 저장소에는 빌드 된 정적 파일들만 저장되고 있다. blog 저장소에서 블로그에 관한 모든 것들을 관리하고 yuchanjeong.github.io 저장소는 서브 모듈로 관리하고 있는데 git clone을 한 뒤 push를 했을 때 blog 저장소에는 정상적으로 반영이 되나 yuchanjeong.github.io 저장소에는 전혀 반영이 되지 않는 문제가 발생했다.\n해결 # 문제의 원인은 일반 클론 시 서브 모듈까지 클론하지 않기 때문이었다. 그래서 git clone --recurse-submodules를 통해 서브 모듈까지 클론해 줬다. 하지만 여전히 문제가 해결되지 않았고, cd public을 통해 서브 모듈로 이동한 뒤 확인해 보자 서브 모듈의 현재 브랜치가 main이 아니었다. 그래서 서브 모듈의 브랜치를 main으로 변경해 주자 문제가 해결되었다.\n*만약 기존 폴더를 그대로 사용한다면 git pull origin main --rebase를 통해 변경사항을 당겨 받은 뒤 서브 모듈로 이동해 git pull origin main -f를 통해 서브 모듈의 변경사항도 당겨 받으면 된다.\nEtc # 서브 모듈 등록 git submodule add -b main https://github.com/YuchanJeong/yuchanjeong.github.io.git public 원격 저장소의 서브 모듈로 업데이트 하기 git submodule update --remote 스크립트의 개행 제거 vi -b up.sh :%s/control+v -\u0026gt; control+m//g ","date":"31 October 2022","permalink":"/posts/etc/1/","section":"Posts","summary":"배경 # 취업을 하게 되면서 컴퓨터 두 대(개인 컴퓨터와 회사 컴퓨터)를 이용해 블로깅을 하게 되었고, 이 과정에서 서브 모듈 관련 문제를 만났다.","title":"깃허브 블로그 서브 모듈 문제"},{"content":"","date":"29 October 2022","permalink":"/categories/%5Cbooks/","section":"Categories","summary":"","title":"\\books"},{"content":"","date":"29 October 2022","permalink":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%80%EC%93%B0%EA%B8%B0/","section":"Tags","summary":"","title":"개발자의 글쓰기"},{"content":" 개발자의 글쓰기는 \u0026lsquo;정확\u0026rsquo;하고 \u0026lsquo;간결\u0026rsquo;하고 \u0026lsquo;가독성\u0026rsquo;이 높아야 한다.\n1) 기초 # 두괄식 - 핵심 설명 후 부가 설명 구조화 - 들여쓰기 활용 Ps1. 함수명에 사용하는 영단어 뉘앙스 차이\nstop(중지) / restart(재개) end(종료) / start(시작) finish(완전 종료) / pause(일시 중지) / hold(의도를 지닌 중지) get(획득) / retrieve(검색 후 획득) / acquire(독점 획득) / fetch(다음 대상 획득) set(할당) / init(초기값 할당) create(틀을 만듦) / register(만들어진 틀에 입력) change(내용 변화) / modify(틀린 내용 수정) / revise(새로운 내용으로 개정) do(행동) / must(필수) / should(권고) is(boolean 데이터) Ps2. \u0026ldquo;-조사\u0026rdquo;, \u0026ldquo;-하다\u0026rdquo;, \u0026ldquo;숫자-\u0026rdquo;, \u0026ldquo;-기호-\u0026ldquo;만 붙여 쓰고 나머지는 띄어 씀\n2) 네이밍과 주석 # 기본적인 네이밍 컨벤션 클래스와 컴포넌트 - PascalCase\n함수와 변수 - camelCase\n상수 - UPPER_DELIMITER_CASE\n패키지와 모듈 - lowercase 명사+명사+명사 (변수) 형용사+명사+명사 (변수) 동사+명사+명사 (함수) BEM 클래스 표기법 - 대상__요소\u0026ndash;상태 변수명 명확한 의미(E.g. d, day(X) -\u0026gt; today, someday(O)) 복수형은 짧을 때는 \u0026ldquo;-s\u0026rdquo;, 길 때는 \u0026ldquo;listOf-\u0026ldquo;나 \u0026ldquo;arrayOf-\u0026ldquo;로 표현 함수명 필요한 기능을 문장으로 작성 함수는 시스템이 할 일이기 때문에 사용자가 할 일은 삭제 중복 내용을 삭제하며 문장 정리 후 분리 1함수 1기능 원칙으로 문장 재분리 기능별 함수 작성 이름이 기능을 명확하게 설명해야 함 설명이 안될 경우 함수를 더 분리해야 함 좋은 이름의 기준 SMART Easy to Search 고전적 범주화 E.g. userBuyer, userPayer, userRegister Easy to Mix 상위 태그와 조합 E.g. h1.title, h2.title, p.title Easy to Agree 구별할 필요가 없는 것까지 이름을 새로 지을 필요 없음 Easy to Remember 이미 널리 알려진 용어는 그냥 쓰는 것이 효율적 Easy to Type 입력하기 쉽고 오타를 낼 가능성이 적은 이름 주석 코드는 의미를, 주석은 의도를 주석은 디버깅으로 바로 잡을 수 없으니 개발자가 신경 써야 함 3) 에러 메시지와 선택지 # 에러의 내용, 원인, 해결법을 알려 줘야 함 \u0026ldquo;예 / 아니오\u0026rdquo; 보다는 구체적인 선택지를 제시 E.g. \u0026ldquo;페이지에 머물기 / 페이지에서 나가기\u0026rdquo; 순서에 일관성이 있어야 함 비활성화를 활용해 에러 예방 가능 4) 릴리스 문서와 장애 보고서 # a. 릴리즈 문서\n선정: 회사와 개발자가 말하고 싶은 것과 독자가 듣고 싶은 것 중 두 개 이상 만족하는 것 선정 분류: 독자에 따라 \u0026ldquo;개발 관점에서 비슷한 내용\u0026rdquo; 혹은 \u0026ldquo;사용 관점에서 비슷한 내용\u0026quot;으로 분류 요약: 불필요한 부사, 형용사, 조사, 어미 제거 종합: 종합은 분석의 개념화와 반대로 특징이나 결과로 서술 Ps. Semantic Versioning - major(호환 X).minor(새로운 기능).patch\nb. 장애 보고서\n문제, 문제점, 해결책, 후순 계획 순서로 작성 면책 조항 필수 필수, 권장, 선택, 예외 사항 표기 장애 보고서 구성 장애 내용 장애 영향 장애 원인 조치 사항 조치 결과 핵심 원인 향후 대책 장애의 근본 원인을 찾기 위해 원인의 원인을 계속 찾아라(5 whys) 재발을 막기 위해서는 원인 대신 이유를 묻고 사람 주어로 대답하라 개발 관점은 기능이 작동하지 않은 것, 비즈니스 관점은 손실이 발생한 것 모호하게 말고 정확한 정보를 적어라(E.g. 재발 가능성 30%) 5) 개발 가이드 # 서비스 개념을 범주, 용도, 특징으로 설명하라 용도는 범주의 핵심 기능을 써라 특징은 장점(자신 기준)과 강점(경쟁사와 비교)에서 뽑아 써라 이해를 돕기 위해 그림과 글로 묘사해라 주관적 묘사와 객관적 묘사를 둘 다 써라 의견을 쓰려면 근거를 대라 주장과 이유, 문제와 답의 거리를 좁혀라 순서에서 단계를 단계에서 목차를 만들어라 6) SI 제안서 # 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 탁월할 때, 경쟁사와 비교하여 강점들을 제안하라 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 부족할 때, 일단 동감하고 경쟁사와 다른 방안을 제시하라 고객의 문제인식이 사소하고 제안사의 문제 해결 능력이 탁월할 때, 고객이 문제를 중대하게 인식하게 만들어라 고객의 문제인식이 사소하고 제안사의 문제 해결 능력이 부족할 때, 경쟁사의 전략을 확인해서 대처하라 요구사항을 분석하지말고 제시하라 변화하는 요구사항에 대비하라 - Two Track(전체 검수와 기능별 검수) 개발 시간 대비 고객의 예상 만족도가 높은 것 위주로 개발하라 7) 기술 블로그 # 주제 의식을 버리고 소재 의식으로 쓰자 독자 수준이 아니라 자기 수준으로 쓰자 저 직접 경험하고 실험한 과정이나 결과*목차를 잘 잡고 본문부터 써라 술 어떤 것을 분석하여 의미를 풀이하고 해석한 것*원전을 비교하고 실험해 풀이해서 써라 편 산만하고 복잡한 자료를 편집해 질서를 부여한 것*순서를 요약해서 써라 집 여러 사람의 견해나 흩어진 자료를 한데 모아 정리한 것*자료를 모아 핵심을 엮어 써라 ","date":"29 October 2022","permalink":"/posts/books/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%80%EC%93%B0%EA%B8%B0/","section":"Posts","summary":"개발자의 글쓰기는 \u0026lsquo;정확\u0026rsquo;하고 \u0026lsquo;간결\u0026rsquo;하고 \u0026lsquo;가독성\u0026rsquo;이 높아야 한다.","title":"개발자의 글쓰기 - 김철수"},{"content":"","date":"29 October 2022","permalink":"/tags/%EA%B9%80%EC%B2%A0%EC%88%98/","section":"Tags","summary":"","title":"김철수"},{"content":"","date":"1 January 0001","permalink":"/categories/%5Csummaries/","section":"Categories","summary":"","title":"\\summaries"},{"content":"1) 기본 설정 # Command Details git init 깃 추적 시작 git config --global --list 기본 설정 보기 git config --global core.autocrlf true 개행문자 설정 git config --global user.name YuchanJeong 사용자 이름 설정 git config --global user.email yuchanjeong0923@gmail.com 사용자 메일 설정 git config --global core.editor vim 기본 에디터 설정 git config --global init.defaultBranch main 기본 브랜치 설정 git config --global commit.template ~/.gitmessage.txt 커밋 템플릿 설정 .vimrc\rset nocompatible \u0026#34; 오리지날 VI와 호환하지 않음 set autoindent \u0026#34; 자동 들여쓰기 set cindent \u0026#34; C 프로그래밍용 자동 들여쓰기 set smartindent \u0026#34; 스마트한 들여쓰기 set wrap set nowrapscan \u0026#34; 검색할 때 문서의 끝에서 처음으로 안돌아감 set nobackup \u0026#34; 백업 파일을 안만듬 set noswapfile \u0026#34;set visualbell \u0026#34; 키를 잘못눌렀을 때 화면 프레시 set ruler \u0026#34; 화면 우측 하단에 현재 커서의 위치(줄,칸) 표시 set shiftwidth=4 \u0026#34; 자동 들여쓰기 4칸 set number \u0026#34; 행번호 표시, set nu 도 가능 set fencs=ucs-bom,utf-8,euc-kr.latin1 \u0026#34; 한글 파일은 euc-kr로, 유니코드는 유니코드로 set fileencoding=utf-8 \u0026#34; 파일저장인코딩 set tenc=utf-8 \u0026#34; 터미널 인코딩 \u0026#34;set expandtab \u0026#34; 탭대신 스페이스 set hlsearch \u0026#34; 검색어 강조, set hls 도 가능 set ignorecase \u0026#34; 검색시 대소문자 무시, set ic 도 가능 set tabstop=4 \u0026#34; 탭을 4칸으로 set lbr set incsearch \u0026#34; 키워드 입력시 점진적 검색 set cursorline \u0026#34; 편집 위치에 커서 라인 설정 set laststatus=2 \u0026#34; 상태바 표시를 항상한다 syntax on \u0026#34; 구문강조 사용 filetype indent on \u0026#34; 파일 종류에 따른 구문강조 set background=dark \u0026#34; 하이라이팅 lihgt / dark set backspace=eol,start,indent \u0026#34; 줄의 끝, 시작, 들여쓰기에서 백스페이스시 이전줄로 set history=1000 \u0026#34; vi 편집기록 기억갯수 .viminfo에 기록 highlight Comment term=bold cterm=bold ctermfg=4 \u0026#34; 코멘트 하이라이트 set mouse=a \u0026#34; vim에서 마우스 사용 set t_Co=256 \u0026#34; 색 조정 2) 원격 저장소 # Command Details git remote -v 원격 저장소 연결 확인 git remote add [name] [url] 원격 저장소 연결 git remote remove [name] 원격 저장소 연결 해제 git push [name] [branch] (-f) 원격 저장소에 Push (강제) git pull [name] [branch] (--rebase) 원격 저장소 Pull (이어 붙히기) git clone [url] ([directory]) 원격 저장소 복사 (폴더명) 3) 파일 상태 # Command Details git status 파일 상태 확인 git diff 파일 상태 비교*작업역역과 스테이지 차이 git diff --cached 파일 상태 비교*스테이지와 저장소 차이 git diff [commit] [commit] 커밋 간 상태 비교 git diff [branch] [branch] 브랜치 간 상태 비교 4) 스테이징 (추가) # Command Details git add -p 변경 내용을 확인 후 청크 별로 추가*y(추가), n(제외), q(종료) git add [directory] 해당 폴더 및 하위 폴더의 변경 내용을 추가 git add . 현재 폴더 및 하위 폴더의 변경 내용을 추가 5) 커밋 (확정) # Command Details git commit 커밋 생성 git commit -m \u0026ldquo;[msg]\u0026rdquo; 커밋 메시지와 함께 커밋 생성 git commit -am \u0026ldquo;[msg]\u0026rdquo; 스테이징 후 커밋 메시지와 함께 커밋 생성 *한 번 이상 커밋 한 파일만 가능 git commit --amend 마지막 커밋 메시지 수정 6) 커밋 기록 # Command Details git log 커밋 기록 보기 git log -p 커밋 기록과 패치내용 보기 git log --stat 커밋 기록과 패치통계 보기 git log --graph 커밋 기록과 그래프 보기 git log [branch]..[branch] 후자에만 있는 커밋 기록 보기 7) 되돌리기 # Command Details git reset --hard [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋, 스테이징, 작업 초기화 git reset [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋, 스테이징 초기화 git reset --soft [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋 초기화 git revert [commit] 해당 커밋의 수정사항 취소 후 새 커밋 생성 git revert [commit]..[commit] 해당 범위의 수정사항 취소 후 새 커밋 생성 git rebase -i [commit] | HEAD[~n] p: 커밋 그냥 사용, 재정렬 및 삭제 가능r: 커밋 메시지 수정e: 커밋 메시지 및 내용 수정*HEAD가 해당 커밋으로 이동, 추가 작업 가능*git rebase --continue (작업 종료)*git rebase --abort (작업 중단)s: squash merged: 커밋 삭제 8) 임시 저장 # Command Details git stash (-u) 임시 저장 후 직전 커밋 상태로 되돌아감 (새 파일도)*한 번 이상 스테이징 한 파일만 가능 git stash list 임시 저장 목록 보기 git stash apply (stash@{[n]}) 최근(해당) 임시 저장 상태로 돌아가기 git stash drop (stash@{[n]}) 최근(해당) 임시 저장 상태 지우기 git stash pop 최근 임시 저장 상태 apply 후 drop 9) 브랜치 # Command Details git branch (-a) 브랜치 목록 보기 (원격 목록도) git branch [branch] 브랜치 생성 git branch -d [branch] 해당 브랜치 삭제 git branch -m [branch] [branch] 브랜치명 바꾸기 git checkout [branch] 브랜치 전환 git checkout -b [branch] 브랜치 생성 후 전환 git merge [branch] (--squash) 현재 브랜치에 해당 브랜치 병합 (스쿼시 병합) git rebase [branch] 현재 브랜치에 해당 브랜치 이어 붙이기 10) 삭제 # Command Details git rm (--cached) [file] 해당 파일 삭제 (원격에서만) git rm -r (--cached) [directory] 해당 폴더 삭제 (원격에서만) git fetch --all --prune 원격 브랜치 흔적 삭제 Etc # 1) .gitignore # List Details example.xxx 해당 파일명 전부 제외 /example.xxx 현재 폴더의 해당 파일 제외 example/ 해당 폴더와 하위 경로 제외 example/example.xxx 해당 폴더의 해당 파일 제외 *.xxx 특정 확장자 파일 전부 제외 !example.xxx 예외 파일명 (버전 관리 ON) 2) SSH 등록 # ssh-keygen으로 ~/.ssh/에 id_rsa.pub(공개키)와 id_rsa(개인키) 생성 공개키를 Github의 Settings/SSH and GPG keys에 등록 3) Github 계정 오류 # 키체인 접근 -\u0026gt; github.com ","date":"1 January 0001","permalink":"/posts/summaries/git/","section":"Posts","summary":"1) 기본 설정 # Command Details git init 깃 추적 시작 git config --global --list 기본 설정 보기 git config --global core.","title":"Git"},{"content":"","date":"1 January 0001","permalink":"/tags/javascript/","section":"Tags","summary":"","title":"javascript"},{"content":"JS Data # 1. Type # Data Type Details string - 쌍따음표(\u0026quot;\u0026quot;)나 따음표(\u0026rsquo;\u0026rsquo;)로 감싸서 표현\n- Template literals(`${변수}`)로 변수 사용 가능\n- +로 합치기 가능(이때 다른 타입은 문자화)\n- str[n]으로 character 읽기 가능(read only)\n- String(data), data.toString()으로 문자화 가능\n*Escape Sequence\nㅤ└ \\n (new line)\nㅤ└ \\t (tap) number - Number(str)로 숫자화 가능\nㅤ*숫자가 아닌 문자열이 있으면 NaN\n- parseInt(str)로 정수화 가능, parseFloat(str)으로 숫자화 가능\nㅤ*숫자가 아닌 문자열이 뒤에 있으면 숫자인 부분까지 숫자화 boolean true | false array - 대괄호([])로 감싸서 표현\n- arr[i]로 element 읽기 가능\n- arr[i] = value로 arr의 i index에 value 할당 가능\n- new Array.from({ length: n })으로 n개의 undefined를 가진 배열 생성 가능\n- new Array(n).fill(element)로 n개의 element를 가진 배열 생성 가능 object - 중괄호({})로 감싸서 표현\n- odj.key와 obj[str]으로 value 읽기 가능\n- odj.key = value와 obj[str] = value로 obj의 key에 value (생성)할당 가능\n- delete obj[str]로 key-value 삭제 가능\n- str in obj로 key 존재 여부 판단 가능*Optional Chainingㅤ└ obj.key1?.key2는 key1이 있을 때만 key2 확인 null 의도적으로 비움 undefined 값이 할당되지 않음 *falsy\nfalse, null, undefined, \u0026ldquo;\u0026rdquo;, 0, NaN (나머지는 truthy) *typeof\n평가 전 데이터 타입을 string으로 반환 function은 \u0026ldquo;function\u0026rdquo; undeclared variable은 \u0026ldquo;undefined\u0026rdquo; null과 array는 \u0026ldquo;object\u0026rdquo; null은 data === null로 판단 array는 Array.isArray(data)로 판단 NaN은 isNaN(number)으로 판단 2. Properties \u0026amp; Methods # 1) String # Properties \u0026 Methods Return str.length 문자열 안의 코드 유닛 수 str.indexOf(searchValue[, fromIndex]) searchValue의 첫 번째 등장 인덱스,\n찾을 수 없으면 -1\n*.lastIndexOf()는 마지막 등장 인덱스 str.includes(searchValue[, fromIndex]) searchValue를 포함하고 있는지 여부 str.slice(beginIndex[, endIndex]) 추출된 부분(~이상~미만)을 담는 새로운 string str.split([separator[, limit]]) separator(문자열|정규식)로 끊은 문자열들의 array str.match(regexp) 정규식과 일치하는 문자열을 포함하는 array,\n찾을 수 없으면 null\n*g옵션이 없을 때 캡처된 그룹 및 정보도 배열에 포함 str.replace(regexp|subStr, newSubStr|function) 패턴과 처음 일치하는 부분이 교체된 새로운 string\n*.replaceAll()은 모든 일치 문자 교체 str.toUpperCase()\nstr.toLowerCase() 모두 대문자로 바꾼 string\n모두 소문자로 바꾼 string str.trim() 양끝의 공백을 제거한 string 2) Number \u0026amp; Math # Properties \u0026 Methods Return num.toFixed([digits]) 고정 소수점 표기법을 사용하여 나타낸 수의 string\n*digits: 소수점 뒤에 나타날 자릿수, 기본값 0 Math.abs(x) 숫자의 절댓값 Math.max([x[, y[, …]]])\nMath.min([x[, y[, …]]]) 0개 이상의 인수 중에서 제일 큰 수\n0개 이상의 인수 중에서 제일 작은 수 Math.ceil(x)\nMath.floor(x)\nMath.round(x) 인수보다 크거나 같은 수 중에서 가장 작은 정수\n인수보다 작거나 같은 수 중에서 가장 큰 정수\n인수에 가장 가까운 정수 Math.sqrt(x) √x Math.pow(x, n) x의 n제곱값 Math.random() 0 이상 1 미만의 부동소수점 의사 난수 3) Array # Properties \u0026 Methods Return arr.length 배열 안의 요소 수\n*arr.length === 0은 빈 배열 arr.indexOf(searchValue[, beginIndex]) searchValue의 첫 번째 등장 인덱스,\n찾을 수 없으면 -1\n*.lastIndexOf()는 마지막 등장 인덱스 arr.includes(searchValue[, beginIndex]) searchValue를 요소로 포함하고 있는지 여부 arr.slice(beginIndex[, endIndex]) 추출된 부분(~이상~미만)을 담는 array arr.join([separator]) 모든 요소를 separator로 구분지어 연결한 string\n*separator를 생략하면 쉼표(,)로 구분 arr.concat([value1[, ...[, valueN]]]) 콜백 배열이나 값들을 기존 배열에 합친 array arr.forEach(callback(currentValue\n[, index[, array]])[, thisArg]) undefined\n*콜백 함수를 각 요소에 대해 실행 arr.map(callback(currentValue\n[, index[, array]])[, thisArg]) 콜백 함수를 각 요소에 대해 실행한 결과의 array arr.filter(callback(currentValue\n[, index[, array]])[, thisArg]) 콜백 함수의 결과가 참인 요소의 array arr.find(callback(currentValue\n[, index[, array]])[, thisArg]) 콜백 함수의 결과가 참인 요소 중 첫 번째 item,\n찾을 수 없으면 undefined arr.findIndex(callback(currentValue\n[, index[, array]])[, thisArg]) 콜백 함수의 결과가 참인 요소 중 첫 번째 요소의 인덱스,\n찾을 수 없으면 -1 arr.reduce(callback(accValue[, curValue\n[, curIndex[, array)[, initialValue]]]]) 콜백 함수의 누적 결과 값(last accValue)\n*initialValue는 첫 accValue의 값이며,\n생략 시 arr[0]이 첫 accValue, arr[1]이 첫 curValue arr.sort([compareFunction]) 정열된 array(원본) arr.reverse() 순서가 반전된 array(원본) arr.splice(beginIndex[, deleteCount\n[, item1[, ...[, itemN]]]]) 제거한 요소를 담은 array\n*배열(원본)의 요소를 교체\n*deleteCount를 생략하면 배열(원본)의 마지막까지 삭제 arr.push(item1[, ...[, itemN]]) 요소가 추가된 배열의 새로운 length\n*배열(원본)의 끝에 하나 이상의 요소를 추가\n*.unshift()는 배열(원본)의 앞에 추가 arr.pop(item1[, ...[, itemN]]) 배열의 마지막 item\n*배열(원본)의 마지막 요소 삭제\n*.shift()는 배열(원본)의 첫 번째 요소 삭제 arr.flat([depth]) depth 번 만큼 다차원 배열을 푼 array\n*depth의 기본값은 1 *beginIndex, endIndex의 값이 음수일 때, 끝에서부터의 위치를 의미 4) Object # Properties \u0026 Methods Return Object.assign(target, ...sources) 출처 객체들로부터 하나 이상의 속성들이 복사된 목표 object\n*동일한 키를 갖는 속성은 뒤의 출처 값으로 덮어쓰여짐 Object.keys(obj) 모든 속성의 키(문자열)를 반환한 array\n*Object.values(obj)는 값의 array Object.fromEntries(arr) [key, value] 형태의 다차원 배열을 변환한 object\n*Object.entries(obj)는 [key, value] 형태의 이차원 array Object.hasOwnProperty(key) 특정 프로퍼티를 가지고 있는지 여부 3. Etc # 1) Destructuring Assignment(구조 분해 할당)\n배열/객체의 속성을 해체 후 그 값을 개별 변수에 할당하는 표현식\nArray const arr = [1, 2, 3, 4, 5]; const [a, , b, ...rest] = arr; // a는 1, b는 3, rest는 [4, 5] Object const obj = { name: \u0026#34;X\u0026#34;, age: 10, gender: \u0026#34;male\u0026#34; }; const { name, gender: sex, address = \u0026#34;Korea\u0026#34; } = obj; // name는 \u0026#34;X\u0026#34;, sex는 \u0026#34;male\u0026#34;, address는 \u0026#34;Korea\u0026#34; 2) Spread Syntax(전개 구문)\n\u0026hellip;data의 형태로 문자열·배열·객체를 펼치는 표현식\nString const str = \u0026#34;Che\u0026#34;; // [...str]는 [\u0026#34;C\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;] // {...str}는 { \u0026#34;0\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;1\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;e\u0026#34; } Array const arr1 = [1, 2, 3]; // [...arr1]은 [1, 2, 3], !== arr1 // {...arr1}는 { \u0026#34;0\u0026#34;: 1, \u0026#34;1\u0026#34;: 2, \u0026#34;2\u0026#34;: 3 } const arr2 = [4, 5, 6]; // [...arr1, ...arr2]는 [1, 2, 3, 4, 5, 6] Object const obj = { a: 1, b: 2, c: 3 }; // {...obj1}은 { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3 }, !== obj1 const obj2 = { c: 1, d: 2, e: 3 }; // {...obj1, ...obj2}는 { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 1, \u0026#34;d\u0026#34;: 2, \u0026#34;e\u0026#34;: 3} Rest Prams const func = (team, ...members) =\u0026gt; ({ 팀: team, 멤버: members }); const myTeam = func(\u0026#34;KT\u0026#34;, \u0026#34;Smeb\u0026#34;, \u0026#34;Score\u0026#34;, \u0026#34;Ucal\u0026#34;, \u0026#34;Deft\u0026#34;, \u0026#34;Mata\u0026#34;); /* myTeam은 { 팀: \u0026#34;KT\u0026#34;, 멤버: [\u0026#34;Smeb\u0026#34;, \u0026#34;Score\u0026#34;, \u0026#34;Ucal\u0026#34;, \u0026#34;Deft\u0026#34;, \u0026#34;Mata\u0026#34;], }; */ 3) Immutability(불변성)\nPrimitive Type(원시 타입) string, number, boolean, undefined, null 변수에 값을 저장 immutable Reference Type(참조형 타입) array, object, function 변수에 heap의 주소를 저장, 값은 heap에 저장 같은 주소(heap)를 참조할 때 하나 변화 시 일괄 변화 mutable 4) Shallow Copy(얕은 복사) \u0026amp; Deep Copy(깊은 복사)\nShallow Copy 복사한 참조형 데이터 내부의 참조형 데이터는 같은 주소 참조 Deep Copy 복사한 참조형 데이터 내부의 참조형 데이터도 다른 주소 참조 JS Operator # 1) Ternary Operator(삼항 연산자)\n조건 ? 조건이 true일 때 : 조건이 false일 때 2) Logical Operator(논리 연산자)\nOperator Details \u0026\u0026 - and (모두 truthy일 때 true)\n- leftExpr \u0026\u0026 rightExpr\nㅤ└ leftExpr이 truthy일 때, rightExpr\nㅤ└ leftExpr이 falsy일 때, leftExpr || - or (하나라도 truthy일 때 true)\n- leftExpr || rightExpr\nㅤ└ leftExpr이 truthy일 때, leftExpr\nㅤ└ leftExpr이 falsy일 때, rightExpr ?? - leftExpr ?? rightExpr (nullish coalescing(널 병합))\nㅤ└ leftExpr이 null 혹은 undefined가 아닐 때, leftExpr ㅤ└ leftExpr이 null 혹은 undefined 때, rightExpr ! - not (falsy일 때 true) 3) Comparison Operator(비교 연산자)\nOperator Details a === b 값과 타입이 같을 때 true a !== b 값이나 타입이 다를 때 true a \u003e b a \u003e b일 때 true a \u003c b a \u003c b일 때 true a \u003e= b a \u003e= b일 때 true a \u003c= b a \u003c= b일 때 true 4) Arithmetic Operator(산술 연산자)\nOperator Details a + b 덧셈 a - b 뺄셈 a * b 곱셈 a / b 나눗셈 a % b 나머지 5) Assignment Operator(할당 연산자)\nOperator Details a += b a = a + b a -= b a = a - b a *= b a = a * b a /= b a = a / b a %= b a = a % b 6) Increment Operator(증감 연산자)\nOperator Details a++/-- 연산 후 1증가/감소 ++/--a 1증가/감소 후 연산 JS Control Statement # 1) Conditional Statement(조건문)\nif 조건문 if (조건1) { 조건1이 truthy일 때 } else if (조건n) { 조건n이 truthy일 때 } else { 조건이 모두 falsy일 때 } switch 조건문 switch (대상) { case 케이스n: 대상이 케이스n일 때 break; default: 해당 케이스가 없을 때 } 2) Iterative Statement(반복문)\nfor 반복문\nfor (초기값; 반복 조건; 증감값) { 반복내용; } // for of 배열 for (let item of iterator) { 반복내용; } // for in 객체 for (let key in object) { 반복내용; } while 반복문\nwhile (반복 조건) { 반복 내용 } Escape Details break 해당 반복문 종료 continue 해당 반복 내용을 종료하고 다음 반복으로 넘어감 label 해당 label의 반복문을 대상으로 함 outer: for (item of arr) { inner: for (el of item) { if (el === 0) { break outer; } if (el === 1) { continue inner; } } } JS Function # 1) 함수 작성\nNamed Function Declaration(기명 함수 선언)\nfunction 함수() {} 호이스팅 시 일시적 사각지대(코드 실행 전까지 초기화가 일어나지 않음)에 빠지지 않음 Anonymous Function Expression(익명 함수 표현)\nconst 변수 = function () {}; Arrow Function(화살표 함수)\nconst 변수 = () =\u0026gt; {}; 인자가 하나일 때, 인자의 소괄호 생략 가능 { return } 생략 가능 객체 데이터는 소괄호로 묶어야 함 메서드 함수로 적합하지 않음 생성자 함수로 사용할 수 없음 2) 고차 함수\nTimer Function(타이머 함수)\nType Details setTimeout(함수, ms) 일정 시간 후 함수 실핼 setInterval(함수, ms) 일정 시간 마다 함수 실행 clearTimeout(변수) 해당 Timeout 함수를 종료 clearInterval(변수) 해당 Interval 함수를 종료 Callback Function(콜백 함수)\n함수의 「인자」로 사용되는 함수 function timeout(cb) { setTimeout(() =\u0026gt; { console.log(\u0026#34;start\u0026#34;); // 함수의 실행 위치 보장 cb(); }, 1000); } timeout(() =\u0026gt; { console.log(\u0026#34;done\u0026#34;); }); Closure Function(클로저 함수)\n함수를 return하는 함수 외부 함수의 「변수」를 내부 함수에서 재사용 const makeCounter = (x) =\u0026gt; { // 함수 변경 없이 value에 할당 불가능 (캡슐화) let value = x; // 내부함수 여러개 생성 가능 return { // 스코프 체이닝 (하위 스코프 우선) up: (x) =\u0026gt; { value += x; return value; }, down: (y) =\u0026gt; { value -= y; return value; }, }; }; // 함수 재활용 가능 const counter1 = makeCounter(1); const counter2 = makeCounter(2); counter1.up(7); // -\u0026gt; 8 counter2.down(7); // -\u0026gt; -5 counter2.up(7); // -\u0026gt; 2 // counter1과 counter2의 value는 서로에게 영향 X Curry Function(커리 함수)\n함수를 return하는 함수 외부 함수의 「인자」를 내부 함수에서 재사용 const greeting = (x) =\u0026gt; { return (y) =\u0026gt; { return `${x} ${y}`; }; }; // 함수 재활용 가능 const hello = greeting(\u0026#34;Hello\u0026#34;); const goodMorning = greeting(\u0026#34;goodMorning\u0026#34;); hello(\u0026#34;guys\u0026#34;); // -\u0026gt; \u0026#39;Hello guys\u0026#39; hello(\u0026#34;ladies\u0026#34;); // -\u0026gt; \u0026#39;Hello ladies\u0026#39; goodMorning(\u0026#34;guys\u0026#34;); // -\u0026gt; \u0026#39;goodMorning guys\u0026#39; goodMorning(\u0026#34;ladies\u0026#34;); // -\u0026gt; \u0026#39;goodMorning ladies\u0026#39; JS Class # /* 1) 클래스 */ class Vehicle { //# constructor: 클래스의 파라미터 constructor(name, wheel) { this.name = name; this.wheel = wheel; } //# static property: 클래스에서 참조 가능한 프로퍼티 static hi = \u0026#34;hi\u0026#34;; //# static method: 클래스에서 호출 가능한 메서드 static isVehicle(vehicle) { return vehicle instanceof Vehicle; } //# (public) property: 내부 및 인스턴스 참조 가능한 프로퍼티 bye: \u0026#34;bye\u0026#34;; //# (public) method: 내부 및 인스턴스에서 호출 가능한 메서드 beep() { console.log(\u0026#34;beep!\u0026#34;); } } /* 2) 클래스 상속 */ class Car extends Vehicle { constructor(name, wheel, year) { //# super-1: 상위 클래스의 파라미터 super(name, wheel); this.year = year; } getWheel() { //# super-2: 상위 클래스의 메서드 super.beep(); console.log(`wheel: ${this.wheel}`); } } /* 3) prototype */ // 공통 메서드 함수는 생성자의 prototype에 할당해서 메모리 절약 // Prototype chain : 해당 객체 -\u0026gt; 생성자 -\u0026gt; 상위 생성자 -\u0026gt; Object Vehicle.prototype.getInfo = function () { console.log(`${this.name}(${this.year})`); }; /* 4) 클래스로 인스턴스(객체) 생성 */ const myCar = new Car(\u0026#34;벤츠\u0026#34;, 4, \u0026#34;2016\u0026#34;); const yourCar = new Car(\u0026#34;BMW\u0026#34;, 4, \u0026#34;2020\u0026#34;); // ========== // Vehicle.hi; // \u0026#34;hi\u0026#34; Vehicle.isVehicle(myCar); // true myCar.bye; // \u0026#34;bye\u0026#34; myCar.beep; // -\u0026gt; beep! myCar.getWheel(); // -\u0026gt; beep! -\u0026gt; wheel: 4 myCar.getInfo(); // -\u0026gt; 벤츠(2016) yourCar.getInfo(); // -\u0026gt; BMW(2020) JS Asynchronous # 추가 예정 JS Etc # 1. DOM # DOM(문서 객체 모델)은 메모리에 웹 페이지 문서 구조를 표현함으로써 스크립트 및 프로그래밍 언어와 페이지를 연결함\nMethods Details document.querySelector(\u0026ldquo;selector\u0026rdquo;) 문서 내에서 selector와 일치하는 첫 번째 요소 document.querySelectorAll(\u0026ldquo;selector\u0026rdquo;) 문서 내에서 selector와 일치하는 NodeList\n*NodeList[i]로 개별 요소 선택\n*for이나 forEach로 요소들 반복처리 document.createElement(\u0026ldquo;tag\u0026rdquo;) 문서 내에 해당 tag 요소 생성\n*아직 DOM tree에 연결 X .appendChild(aChild) 대상의 마지막 자식 노드로 붙임\n*DOM tree에 연결 .addEventListener(\u0026ldquo;event\u0026rdquo;, functionRef*) 이벤트 발생 시 함수 호출\n*event: click|focus|blur|scroll\n*event.target은 이벤트의 대상 요소 .onclick = functionRef* 대상 클릭 시 함수 호출 .classList\nㅤ.add(String [, String [, \u0026hellip;]])\nㅤ.remove(String [, String [, \u0026hellip;]])\nㅤ.contains(String) 클래스 추가\n클래스 삭제\n클래스 포함 여부 .setAttribute(\u0026ldquo;attribute\u0026rdquo;, \u0026ldquo;value\u0026rdquo;)\n.[attribute] = \u0026ldquo;value\u0026rdquo; 속성(HTML) 할당 .style.[property] = \u0026ldquo;value\u0026rdquo; 특성(CSS) 할당 .textContent = \u0026ldquo;content\u0026rdquo; 내용 할당\n*innerText(보안상 사용 금지)와 유사 .remove() 노드를 메모리에서 삭제 .removeChild(aChild) 대상과 자식 노드의 연결을 끊음 .children 자식 요소 목록\n*.firstElementChild는 첫 번째 자식\n*.lastElementChild는 마지막 자식 .parentsElement 부모 요소 *functionRef(Event Handler):\n함수의 실행이 아닌 함수 자체를 넣어야함 아무런 인자를 담지 않으면 event 객체만 전달 특정 인자를 전달하기 위해서는 콜백함수 사용\nㅤEx. eventHandler={(e) =\u0026gt; (param, \u0026hellip;, e) =\u0026gt; {}}; e.preventDefault(); (고유 동작을 막음) e.stopPropagation(); (이벤트 전파를 막음) if (e.target !== e.currentTarget) return; (해당 요소만 이벤트의 대상) 2. Scope \u0026amp; Declarations # Scope Details Global Scope window(브라우저의 객체)에 저장 Function Level Scope var중복 선언 가능 Block Level Scope letㅤ중복 선언 불가능ㅤ값의 재할당 가능constㅤ중복 선언 불가능ㅤ값의 재할당 불가능, 초기화 필수ㅤ참조형 데이터의 요소는 재할당, 추가, 삭제 가능ㅤ *하위 스코프 우선(Scope Chaining)\n*선언(호출 X)된 위치에 따라 상위 스코프 결정(Lexical Scoping)\n3. This # Type Condition Target 일반 함수 호출 1. 일반 호출: 전역 객체2. 메서드 호출: 호출 객체 화살표 함수 선언 화살표 함수를 감싸고 있는 외부 함수의 객체 example const obj1 = { normal: function () { console.log(this); }, arrow: () =\u0026gt; { console.log(this); }, }; obj1.normal(); // 메서드 호출, this === obj1 const obj11 = obj1.normal; obj11(); // 일반 호출, this === window obj1.arrow(); // this === { } // ========== // const obj2 = { normal: function () { setTimeout(function () { console.log(this); }, 1000); }, arrow: function () { setTimeout(() =\u0026gt; { console.log(this); }, 1000); }, }; obj2.normal(); // this === window // obj2의 normal을 메서드 호출 // -\u0026gt; normal의 setTimeout함수(내부함수)를 일반 호출 obj2.arrow(); // this === obj2 // ========== // const obj3 = { name: \u0026#34;yuchan\u0026#34;, outer: function () { console.log(this); // --- (1)obj3 const innerFunc = function () { console.log(this); // --- (2)window (3)obj4 }; innerFunc(); // --- (2) const obj4 = { name: \u0026#34;che\u0026#34;, innerMethod: innerFunc, }; obj4.innerMethod(); // --- (3) }, }; obj3.outer(); // --- (1) // (1)메서드 호출 (2)일반 호출 (3)메서드 호출 4. JSON # Methods Details JSON.stringify(obj) obj -\u0026gt; jsonStr, 직렬화(serialize) JSON.parse(jsonSrt) jsonStr -\u0026gt; obj, 역직렬화(deserialize) *JSON(JavaScript Object Notation)문자열은 쌍따옴표(\u0026quot;\u0026quot;)만 사용 가능\n5. Export \u0026amp; Import # // 이름 필수 X, 파일 하나당 하나만 가능 export default 데이터 // 이름 필수 O, 파일 하나당 여러개 가능 export 데이터 // export default import 임의_데이터명 from \u0026#34;경로\u0026#34;; // export import { 데이터명 } from \u0026#34;경로\u0026#34;; import { 데이터명 as 임의_데이터명 } from \u0026#34;경로\u0026#34;; import * as 임의_객체명 from \u0026#34;경로\u0026#34;; 6. Web Storage(웹 저장소) # vs Cookie\n클라이언트에 정보만 존재 \u0026lt;-\u0026gt; 요청 마다 서버에 함께 전송 (성능 저하 원인, 탈취 위험 높음) 용량 제한이 없음 \u0026lt;-\u0026gt; 있음 만료일이 없음 \u0026lt;-\u0026gt; 있음 Local Storage\n별도로 삭제할 때까지 영구 유지 도메인만 같으면 전역 공유 가능 Methods Details localStorage.setItem(\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;) 데이터 저장 localStorage.getItem(\u0026ldquo;key\u0026rdquo;) 데이터 불러오기 localStorage.removeItem(\u0026ldquo;key\u0026rdquo;) 데이터 삭제 Session Storage\n탭이나 브라우저가 종료되면 삭제 같은 도메인이라도 다른 탭이나 브라우저면 공유 불가능 ","date":"1 January 0001","permalink":"/posts/summaries/javascript/","section":"Posts","summary":"JS Data # 1.","title":"Javascript"}]